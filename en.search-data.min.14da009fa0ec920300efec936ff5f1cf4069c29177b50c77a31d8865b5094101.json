[{"id":0,"href":"/draft/interview/get-post/","title":"GET和POST的区别","section":"面试","content":"GET和POST的区别 #   GET请求在浏览器回退和刷新时是无害的，而POST请求会告知用户数据会被重新提交； GET请求可以收藏为书签，POST请求不可以收藏为书签； GET请求可以被缓存，POST请求不可以被缓存，除非在响应头中包含合适的Cache-Control/Expires字段，但是不建议缓存POST请求，其不满足幂等性，每次调用都会对服务器资源造成影响； GET请求一般不具有请求体，因此只能进行url编码，而POST请求支持多种编码方式。 GET请求的参数可以被保留在浏览器的历史中，POST请求不会被保留； GET请求因为是向URL添加数据，不同的浏览器厂商，代理服务器，web服务器都可能会有自己的长度限制，而POST请求无长度限制； GET请求只允许ASCII字符，POST请求无限制，支持二进制数据； GET请求的安全性较差，数据被暴露在浏览器的URL中，所以不能用来传递敏感信息，POST请求的安全性较好，数据不会暴露在URL中； GET请求具有幂等性(多次请求不会对资源造成影响)，POST请求不幂等； GET请求一般不具有请求体，请求中一般不包含100-continue 协议，所以只会发一次请求，而POST请求在发送数据到服务端之前允许双方\u0026quot;握手\u0026quot;，客户端先发送Expect:100-continue消息，询问服务端是否愿意接收数据，接收到服务端正确的100-continue应答后才会将请求体发送给服务端，服务端再响应200返回数据。  "},{"id":1,"href":"/docs/notes/vim/","title":"vim常用命令","section":"一些杂记","content":"Introduction #  主要记录vim使用过程中的快捷键\n输入模式 #   i 切换输入模式 a 光标后插入 A 光标行尾插入 i 光标前插入 I 光标行首插入 o 打开向下打开新行 O 打开向上打开新行  esc #   退出模式  保存 #   w wq wq！ q! wq! (root 文件所有者可以操作)  快捷键 #   h 向左 j 向下 k 向上 l 向右 gg 文件头 G 文件尾  快速跳转 #   ^ 行首 $ 行尾 :n 跳到指定n 行 x 删除一个字母 xn 删除P指定n个字母 dd 删除单行 ndd 删除n行  剪切/粘贴/撤销 #   p 粘贴光标上面 P 粘贴光标下面 :n1,n2d 剪切多行 n行号 dG 先执行gg文件头 从光标删除到文件尾 u 撤销 一直到文件打开状态 control+r 反撤销  替换 #   r 替换单个 R 替换模式  查找 #   ? 光标向上 / 光标向下 n 下一个 N 上一个  其他 #   r 导入其他文件内容 :r abc.txt !命令 在vim执行系统命令 r !命令 导入命令的结果 map 自定义快捷键 o 上下打开多个文档  control+w 上下箭头 切换文件   O 左右打开多个文档  control+w 左右箭头 切换文件   "},{"id":2,"href":"/draft/javascript/reflect-proxy/","title":"代理和反射","section":"javascript","content":"代理(Proxy)是一种可以拦截并改变底层JavaScript引擎的操作包装器，在新语言中通过它暴露内部运作对象，从而让开发者可以创建内建对象\n代理和反射 #  代理 #  调用new Proxy()可以创建代替其他目标对象的代理，虚拟化了目标，使其二者看起来功能一致，代理可以拦截JavaScript引擎内部目标的底层对象操作，这些底层操作被拦截后会触发响应特定操作的陷阱函数。\n用Proxy构造函数创建代理需要两个参数： 目标(target)和处理程序(handler)，处理程序定义一个或者多个陷阱的对象，除去专门特定的操作定义外，其余操作均使用默认特性\nlet t = {} let p = new Proxy(t, {}) p.name = \u0026#39;hello proxy\u0026#39; console.log(p); // { name: \u0026#39;hello proxy\u0026#39; } console.log(t); // { name: \u0026#39;hello proxy\u0026#39; } 反射 #  反射API以Reflect对象的形式出现，对象中的方法默认特性相应的底层操作一致。而每一个代理陷阱会对应一个命名和参数都相同的Reflect方法(其实就是每个代理陷阱都会对应一个Reflect api接口供覆写JavaScript底层操作)\n代理陷阱特性\n   代理陷阱 覆写的特性 默认特性     get 读写一个属性值 Reflect.get()   set 写入一个属性 Reflect.set()   has in操作 Reflect.has()   deleteProperty delete操作符 Reflect.deleteProperty()   getAPrototypeof Object.getAPrototypeof () Reflect.getAPrototypeof ()   setAPrototypeof Object.setAPrototypeof () Reflect.setAPrototypeof ()   isExtensible Object.isExtensible() Reflect.isExtensible()   preventExtensions Object.preventExtensions() Reflect.preventExtensions()   getOwnPropertyDescriptor Object.getOwnPropertyDescriptor() Reflect.getOwnPropertyDescriptor()   defineaProperty Object.defineaProperty() Reflect.defineaProperty()   ownKeys Object.keys() 、 Object.getOwnPropertyNames()和 Object.getOwnPropertySysmbols() Reflect.ownKeys()   apply 调用一个函数 Reflect.apply()   construct 用new调用一个函数 Reflect.construct()    set陷阱验证(设置属性) #  set陷阱接受4个参数：\n trapTarget 用于接受属性(代理目标)的对象 key 要写入的属性键(字符串或者symbol类型) value 被写入属性的值 receiver 操作发生的对象(通常是代理)  Reflect.set是set陷阱对应的反射方法和默认特性，\nlet target = { \tname:\u0026#39;target\u0026#39; } let proxy = new Proxy(target, {  // receiver 等同于 proxy \tset (trapTarget, key, value, receiver) { \tif (!trapTarget.hasOwnProperty(key)) { \tif (isNaN(value)) { \tthrow new TypeError(\u0026#39;属性必须是数字\u0026#39;) \t} \t} \treturn Reflect.set(trapTarget, key, value, receiver) \t} }) proxy.count = 1 console.log(target.count); // 1 console.log(proxy.count); // 1 proxy.anotherName = \u0026#39;proxy\u0026#39; // TypeError: 属性必须是数字 get陷阱验证(获取属性) #  JavaScript中的困惑行为，当读取一个不存在对象上的属性的时候，会返回undefined，而不是报错\nlet target = {} console.log(target.name) // undefined 可以通过get陷阱来检测，读取属性是否存在\n接受三个参数\n trapTarget 目标对象 key 读取的属性值 receiver 操作发生的对象  let proxy = new Proxy({},{ \tget(trapTarget, key, receiver){ \tif(!(key in receiver)){ \tthrow new TypeError(`属性${key}不存在`) \t} \treturn Reflect.get(trapTarget,key,receiver) \t} }) proxy.name = \u0026#39;proxy\u0026#39; console.log(proxy.name) // proxy proxy.nam // TypeError: 属性nam不存在 has陷阱(in 操作符) #  has陷阱覆写的特性是in操作符；in操作符的作用是来检测给定对象中是否包含某个属性，如果自有属性或原来属性匹配这个名称或Symbol 就返回true\nlet target = { \tvalue:42 } console.log(\u0026#39;value\u0026#39; in target) // true console.log(\u0026#39;toString\u0026#39; in target) // true console.log(\u0026#39;name\u0026#39; in target) // false 使用in操作符会调用has陷阱\n trapTarget Key  let target = { \tvalue:42, \tname: \u0026#39;target\u0026#39; } let porxy = new Proxy(target,{ \thas(trapTarget,key){ \tif(key===\u0026#39;value\u0026#39;){ \treturn false \t} \treturn Reflect.has(trapTarget,key) \t} }) console.log(\u0026#39;value\u0026#39; in porxy) // false console.log(\u0026#39;toString\u0026#39; in porxy) // true console.log(\u0026#39;name\u0026#39; in porxy) // true deleteProperty陷阱(delete ) #  delete可以从对象中移除属性，成功返回true，反正返回false； 在严格模式下删除一个不可配置(noncoonfigurable)属性则会导致程序抛出错误，而非严格模式下只会返回false\nlet target = { \tname:\u0026#39;target\u0026#39;, \tvalue:42 }  Object.defineProperty(target,\u0026#39;name\u0026#39;,{configurable:false}) console.log(\u0026#39;value\u0026#39; in target); // true console.log(delete target.value); // true console.log(\u0026#39;value\u0026#39; in target); // false  console.log(\u0026#39;name\u0026#39; in target); // true // 严格模式 \u0026#39;use strict\u0026#39;; console.log(delete target.name); // TypeError: Cannot delete property \u0026#39;name\u0026#39; of #\u0026lt;Object\u0026gt; deleteProperty陷阱\n trapTarget key  let target = { \tname:\u0026#39;target\u0026#39;, \tvalue:42 }  let proxy = new Proxy(target, { \tdeleteProperty(traptarget, key){ \tif(key===\u0026#39;value\u0026#39;){ \treturn false \t} \treturn Reflect.deleteProperty(traptarget,key) \t} })  console.log(\u0026#39;value\u0026#39; in proxy); // true console.log(delete proxy.value); // false console.log(\u0026#39;value\u0026#39; in proxy); // true 原型代理陷阱 #  "},{"id":3,"href":"/draft/javascript/promise/","title":"promise","section":"javascript","content":"Javascript引擎基于单线程事件循环，同一时间只运行一个代码块运行；反之多线程是运行多个代码块同时执行。\n所以JavaScript需要跟踪即将运行的代码，将这些代码放在一个任务队列中，当代码准备执行的时候都会添加到任务队列中，当一段代码执行结束，事件循环会执行队列下一个任务。队列中的任务会从第一个一直执行到最后一个\n  事件模型：用户点击键盘或者触发类似onclick事件，会想任务队列增加一个任务来响应用户的操作，直到事件触发才执行事件处理程序，这是JavaScript中最基础的异步编程\n  回调模式：Nodejs通过普及回调函数拉改进异步编程模型，异步代码会在未来某个时间执行，回调模式中被调用的函数式作为蚕食传入的。\n  Promise基础 #  promise相当于一个异步操作结果的占位符，它不会去订阅一个事件，也不会传递一个回调函数给目标，而是返回一个Promise。\n// readFili承诺将来某个时刻完成 let promiss = readFile(\u0026#39;example.txt\u0026#39;) 创建Promise #  let fs = require(\u0026#39;fs\u0026#39;) function readFile () { \treturn new Promise((resolve, reject) =\u0026gt; { \tfs.readFile(\u0026#39;filename\u0026#39;, {encoding:\u0026#39;utf8\u0026#39;},function(err, con) { \tif (err) { \treject(err) \treturn \t} \tresolve(con) \t}) \t}); } Promise.resolve #  只接受一个参数，并返回一个完成态的Promise；如果传入的是一个Promise，那么换个Promise会被立即返回\nlet p1 = Promise.resolve(42) p1.then(value=\u0026gt;console.log(value)); // 42 Promise.reject #  只接受一个参数，并返回一个拒绝的Promise；如果传入的是一个Promise，那么换个Promise会被立即返回\nlet p1 = Promise.reject(42) p1.catch(value=\u0026gt;console.log(value)); 生命周期 #    pending 进行中，操作尚未完成，所以是未处理，一旦操作结束会进入到下一个状态\n  Fulfilled 异步操作完成\n  Rejected 异步操作未能完成\n  内部属性[[PromiseState]]被用啦表示3种状态；\u0026ldquo;pending\u0026rdquo;、\u0026ldquo;fulfilled\u0026rdquo;、\u0026ldquo;rejected\u0026rdquo;。这个属性不暴露，所以不能通过编程的方式检测promise状态，只有当promise状态改变，通过then方法拉采取特定行动\n全局拒绝处理 #  浏览器环境的拒绝处理：\n在浏览器中可以通过监听window事件来识别未处理的拒绝\nlet rejected; window.onunhandledrejection = function(event){  console.log(event.type); // unhandledrejection  console.log(event.reason.message); // Explosion  console.log(rejected === event.promise);\t// true } window.onrejectionhandled = function(event){  console.log(event.type);  console.log(event.reason.message);  console.log(rejected === event.promise);\t} rejected = Promise.reject(new Error(\u0026#34;Explosion\u0026#34;)) Nodejs环境的拒绝处理:\n在node中处理promise拒绝时候会触发processs上的事件\n unhandleRejection 在一个事件循环中，当promise被拒绝，并且没有提供相应拒绝程序的时候调用 rejectionHandled 在一个事件循环后，当promise被拒绝，并且没有提供相应拒绝程序的时候调用  let rejected;  process.on(\u0026#39;unhandledRejection\u0026#39;, function(reason, promise){  console.log(reason); // \u0026#39;Explosion\u0026#39;  console.log(rejected === promise) true })  rejected = Promise.reject(new Error(\u0026#34;Explosion\u0026#34;)) Promise 串联 #  每次调用then方法或者catch方法实际会创建并返回另一个promise，只有当第一个完成或者被拒绝后，第二个才会被解决\n let p1 = new Promise((resolve, reject) =\u0026gt; { \tresolve(42) }); p1.then(value =\u0026gt; { \tconsole.log(value); }).then(() =\u0026gt; { \tconsole.log(\u0026#39;finish\u0026#39;);\t}).catch(err =\u0026gt; { \tconsole.log(err); }) // 42 // finish  let p1 = Promise.resolve(1)  let px = function name(params) {  return new Promise((resolve, reject)=\u0026gt;{  setTimeout(()=\u0026gt;{  resolve(2)  },2000)  }) } let arr = [px, undefined]  arr.unshift((value)=\u0026gt;{  console.log(value, \u0026#39;3==\u0026#39;);  return 3 },(value)=\u0026gt;{  console.log(value, \u0026#39;4==\u0026#39;);  return 4 }) arr.push((value)=\u0026gt;{  console.log(value, \u0026#39;5==\u0026#39;);  return 5 },(value)=\u0026gt;{  console.log(value, \u0026#39;6==\u0026#39;);  return 6 })  while (arr.length) {  p1 = p1.then(arr.shift(), arr.shift()) } // 1 3== // 等待 2s 后 // 2 5== promise链的返回值，下一个promise会在上一个完成之后才会执行； 如果在完成处理的程序中返回值，则可以沿着这条链继续传递数据\n let p1 = new Promise((resolve, reject) =\u0026gt; { \tresolve(42) }); p1.then(value =\u0026gt; { \tconsole.log(value); \treturn value +1 }).then((value) =\u0026gt; { \tconsole.log(value);\t}).catch(err =\u0026gt; { \tconsole.log(err); }) //42 // 43 同样错误也可以返回值继续传递，在必要的时候，即使其中一个promise失败也能恢复整个promise链的执行\nlet p1 = new Promise((resolve, reject) =\u0026gt; { \treject(42) }); p1.catch(value =\u0026gt; { \tconsole.log(value); \treturn value+1 }).then(value =\u0026gt; { \tconsole.log(value); }) // 42 //43 Promise.all #  接受一个参数，并返回一个promise，该参数是一个含有多个受监视的Promise对象（比如数组），只有当所有Promise都被解决后返回的Promise才会被解决，只有当可迭代对象中所有的Promise都被完成返回的Promise才会被完成。\n被解决的值是按照顺序储存的，可以根据每个结果来匹配Promise\n所有传入的Promise只要一个被拒绝，那么返回的Promise不会等到都完成，而是立即拒绝\nlet p1 = Promise.resolve(42) let p2 = Promise.resolve(43) let p3 = Promise.resolve(44) Promise.all([p1, p2, p3]).then(value =\u0026gt; { \tconsole.log(value); // [42,43,44] }) // 拒绝 let p1 = Promise.resolve(42) let p2 = Promise.reject(43) let p3 = Promise.resolve(44)  Promise.all([p1, p2, p3]).then(value =\u0026gt; { \tconsole.log(value); }).catch(err =\u0026gt; { \tconsole.log(err); // 43 }) Promise.race #  接受一个参数，并返回一个promise，该参数是一个含有多个受监视的Promise对象（比如数组），只要有一个Promise被解决后返回的Promise就会被解决，无需等到所有的Promise都完成，只要当可迭代对象中有的Promise被完成返回的Promise才会被完成。\n 实际上Promise.race会进行竞选，如果先解决的是已完成，则返回已完成的Promise；如果先解决的是已拒绝，则返回已拒绝的Promise   let p1 = Promise.resolve(42); let p2 = Promise.reject(43) let p3 = Promise.resolve(44)  Promise.race([p1, p2, p3]).then(value =\u0026gt; { \tconsole.log(value); // 42 }).catch(err =\u0026gt; { \tconsole.log(err); }) // 竞选 let p1 = new Promise((resolve, reject) =\u0026gt; { \tsetTimeout(() =\u0026gt; { \tresolve(42) \t},10) }); let p2 = Promise.reject(43) let p3 = Promise.resolve(44)  Promise.race([p1, p2, p3]).then(value =\u0026gt; { \tconsole.log(value); }).catch(err =\u0026gt; { \tconsole.log(err); // 43 }) Promise的继承 #  由于静态方法绘本继承，因此派生类也会拥有resolve、reject、all、race等方法\nclass MyPromise extends Promise{ \tsuccess (resolve, reject) { \treturn this.then(resolve, reject) \t} \tfailure (reject) { \treturn this.catch(reject) \t} } let pro = new MyPromise(function (resolve, reject) { \tresolve(42) }) pro.success(value =\u0026gt; { \tconsole.log(value);\t// 42 }).failure(err =\u0026gt; { \tconsole.log(err); }) "},{"id":4,"href":"/draft/katex/","title":"关于latex格式的前端渲染","section":"Drafts","content":"最近由于工作原因开始接触laex格式的渲染，主要是相关复杂公式的渲染数学公式、物理公式等；渲染方式主要有服务端渲染展示图片、前端渲染html形式展示公式；这里只说说前端渲染前的方式。以前也没有接触过类似的东西通过调研多个库，主要有MathJax、katex的渲染方式；这里主要讲katex的渲染方式。\n什么是latex？ #  摘自维基百科\nLaTeX， 是一种基于TEX的排版系统，由美国电脑学家莱斯利·兰伯特在20世纪80年代初期开发，利用这种格式，即使用户没有排版和程序设计的知识也可以充分发挥由TEX所提供的强大功能，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。 简单的说 LaTeX 基于 TeX，主要目的是为了方便排版。在学术界的论文，尤其是数学、计算机等学科论文都是由 LaTeX 编写, 因为用它写数学公式非常漂亮。 MathJax #  MathJax的官网地址，中文文档地址点这里\n引入MathJax #  官网cdn\n\u0026lt;script type=\"text/javascript\" src=\"http://cdn.mathjax.org/mathjax/1.1-latest/MathJax.js\"\u0026gt;\u0026lt;/script\u0026gt; 因为MathJax是自动识别dom的，引入成功之后如果包含latex格式的标签会自动转换比如： \u0026lt;p\u0026gt;∵集合$$A=\\left\\{ x|x\u0026amp;lt;{}1 \\right.$$或$$\\left. x\u0026amp;gt;3 \\right\\}$$，$$B=\\left\\{ x|2x-4\u0026amp;gt;0 \\right\\}=\\left\\{ x|x\u0026amp;gt;2 \\right\\}$$，\u0026lt;/p\u0026gt; 与此同时官方也给我们提供了配置函数\n\u0026lt;!-- type必须是text/x-mathjax-config --\u0026gt; \u0026lt;script type=\u0026#34;text/x-mathjax-config\u0026#34;\u0026gt; window.MathJax.Hub.Config({  showProcessingMessages: false, //关闭js加载过程信息  messageStyle: \u0026#34;none\u0026#34;, //不显示信息  jax: [\u0026#34;input/TeX\u0026#34;, \u0026#34;output/HTML-CSS\u0026#34;],  tex2jax: {  \u0026lt;!-- 由于MathJax 没有css 所以有些时候会出现样式不对，注意设置好 inlineMath、displayMath 属性--\u0026gt;  inlineMath: [[\u0026#34;$\u0026#34;, \u0026#34;$\u0026#34;], [\u0026#34;\\\\(\u0026#34;, \u0026#34;\\\\)\u0026#34;]], //行内公式选择符  displayMath: [[\u0026#34;$$\u0026#34;, \u0026#34;$$\u0026#34;], [\u0026#34;\\\\[\u0026#34;, \u0026#34;\\\\]\u0026#34;]], //段内公式选择符  skipTags: [\u0026#34;script\u0026#34;, \u0026#34;noscript\u0026#34;, \u0026#34;style\u0026#34;, \u0026#34;textarea\u0026#34;, \u0026#34;pre\u0026#34;, \u0026#34;code\u0026#34;, \u0026#34;a\u0026#34;], //避开某些标签  ignoreClass: \u0026#34;class1|class2\u0026#34; //避开 特定 标签  },  \u0026#34;HTML-CSS\u0026#34;: {  availableFonts: [\u0026#34;STIX\u0026#34;, \u0026#34;TeX\u0026#34;], //可选字体  showMathMenu: false //关闭右击菜单显示  }  }); \u0026lt;/script\u0026gt; 默认情况是对我们整个DOM进行处理的，可以传递参数来指定渲染范围(可以极大的提高渲染性能)\nwindow.MathJax.Hub.Queue([\u0026#34;Typeset\u0026#34;, MathJax.Hub, document.getElementById(\u0026#39;app\u0026#39;)]); MathJax给我们提供了部分右键菜单通过设置可以控制显示\n\u0026#34;HTML-CSS\u0026#34;: {  showMathMenu: false }  默认的公式会有蓝框，我们可以通过设置样式覆盖修改样式\n蓝色的边框 .MathJax{outline:0;} 如果要改变字体大小 .MathJax span{font-size:15px;} 公式太长的时候会溢出 .MathJax_Display{overflow-x:auto;overflow-y:hidden;} 去掉加载信息，MathJax加载会在网页左下角看到加载情况，可以直接在MathJax.Hub.Config()里配置去掉\nMathJax.Hub.Config({  showProcessingMessages: false,  messageStyle: \u0026#34;none\u0026#34; }); 更多 #  更多关于tex2jax的配置点击\n katex 最快的公式渲染 #  katex是可汗学院推出的一种解析latex的库，具有简单的api、无依赖、高效、快速、服务器端渲染的js解析库； 特点：\n 简单的API：不依赖其它 javascript库； 快速：KaTeX 是将其数学同步且不需要回流页； 输出质量：KaTeX 的布局是基于 Donald Knuth 的 Tex ，数学排版的黄金标准； 服务器的渲染：无论浏览器或环境如何，KaTeX 输出保持一致，因此可使用 Node.js 预渲染表达式，并将其作为纯 HTML 发送。  该库只支持纯粹的latex格式的渲染，如果包含html实体、或者标签将渲染失败 官网在此\n引入katex #  1.通过cdn引入\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.css\u0026#34; integrity=\u0026#34;sha384-dbVIfZGuN1Yq7/1Ocstc1lUEm+AT+/rCkibIcC/OmWo5f0EA48Vf8CytHzGrSwbQ\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.js\u0026#34; integrity=\u0026#34;sha384-2BKqo+exmr9su6dir+qCw08N2ZKRucY4PrGQPPWU1A7FtlCGjmEGFqXCv5nyM5Ij\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; // 以下是一个自动渲染的插件 \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/contrib/auto-render.min.js\u0026#34; integrity=\u0026#34;sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 该defer属性 表示在页面加载之前不需要执行脚本，从而加快了页面呈现速度; 和onload属性调用 renderMathInElement一次自动渲染脚本负荷。  document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() {  renderMathInElement(document.body, {  // ...options...  });  }); \u0026lt;/script\u0026gt;   integrity:是允许浏览器检查其获得的资源（例如从 CDN 获得的）是否被篡改的一项安全特性。具体信息请参考web 安全|MDN\n  defer：这个布尔属性被设定用来通知浏览器该脚本将在文档完成解析后，触发 DOMContentLoaded 事件前执行。如果缺少 src 属性（即内嵌脚本），该属性不应被使用，因为这种情况下它不起作用。对动态嵌入的脚本使用 async=false 来达到类似的效果。script|MDN\n  crossorigin:那些没有通过标准CORS检查的正常script 元素传递最少的信息到 {domxref(\u0026lsquo;GlobalEventHandlers.onerror\u0026rsquo;, \u0026lsquo;window.onerror\u0026rsquo;)}。可以使用本属性来使那些将静态资源放在另外一个域名的站点打印错误信息。script|MDN\n  当然还有AMD、ECMAScript module的引入具体请移步官网 如果使用了前端打包工具也可以使用npm引入\nnpm install katex / yarn add katex // 这样全局就会 有katex import katex from \u0026#39;katex\u0026#39;; // 别忘了引入css import \u0026#39;katex/dist/katex.min.css\u0026#39; API #  katex.render #  该方法会将公式渲染的结果返回到elemnet里\n// 官方实例 katex.render(\u0026#34;c = \\\\pm\\\\sqrt{a^2 + b^2}\u0026#34;, element, {  throwOnError: false }); // 如果需要转义那么可以这样 katex.render(String.raw`c = \\pm\\sqrt{a^2 + b^2}`, element, {  throwOnError: false }); 请注意本地复制代码测试的时候要去掉转义字符,不然会出现错误 katex.renderToString #  该渲染方法会将生成的dom结构输出到html\nvar html = katex.renderToString(\u0026#34;c = \\\\pm\\\\sqrt{a^2 + b^2}\u0026#34;, {  throwOnError: false }); renderMathInElement #  插件的使用，引入插件的js后，会获得一个全局的函数renderMathInElement\ndocument.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() {  renderMathInElement(document.body, {  // ...options...  });  }); 该函数提供两个参数，第一个提供dom节点就是说会渲染该dom节点下的公式元素（尽可能的精确会提高性能），第二个参数是分隔符配置文件，将分隔符以内的字符串会进行katex渲染，配置如下\n// display设置为true会被渲染成块元素，false是行内元素  {  delimiters: [  {left: \u0026#34;$$\u0026#34;, right: \u0026#34;$$\u0026#34;, display: false},  {left: \u0026#34;\\[\u0026#34;, right: \u0026#34;\\]\u0026#34;, display: true},  {left: \u0026#34;$\u0026#34;, right: \u0026#34;$\u0026#34;, display: false},  {left: \u0026#34;\\(\u0026#34;, right: \u0026#34;\\)\u0026#34;, display: false }  ] } 这些就是katex的基本api，具体的使用请参考官网\n总结 #  不管是render、还是renderToString都只支持纯公式的渲染一旦包含标签或者其他不是公式的元素字符串那么就会渲染失败，而renderMathInElement插件的渲染虽然良好的支持各种标签混合的字符串处理，但是又不能支持字符串的输出。我简单的修改了下renderMathInElement的源码使之能输出DOM字符串可以直接渲染，如果你使用vue那么会很方便的使用v-html渲染，这样就解决了后端请求的时候的少量渲染，并且不会引起大量的重绘、回流。\n源码点这儿 --  npm 集成v-katex "},{"id":5,"href":"/draft/high-javascript/process-control/","title":"算法和流程控制","section":"高性能JavaScript","content":"循环类型 #  // for循环 for(var i = 0; i\u0026lt;items.length; i++){} // while循环 var i= 0; while(i\u0026lt;items.length){} // do-while var j = 10 ; do{}while(j\u0026lt;items.length) // for-in for(var key in object){  // 函数体 }  // 每次循环所经历的步骤 1. 在控制条件中查找一次属性(items.length) 2. 在控制条件中执行一次数值比较(i\u0026lt;items.length) 3. 一次比较操作,查看控制条件的计算是否为true(i\u0026lt;items.length === true) 4. 一次自增(i++) 5. 一次数值查找(items[i]) 6. 一次函数体执行 减少迭代的工作量 #   for-in循环每次迭代都需要搜索实例和原型,因此每次迭代会带来更多的开销，对比同等次数和\u0008环境for-in循环最终只有\u0008其他循环类型的1/7 2.由于操作局部变量和字面量要比\u0008查找对象成员和数组项的查找要快，对于数组或者对象来说length一般是没有改变的所有通过缓存局部变量可以提高性能   // 大多数浏览器可以节约25%的时间，IE甚至可以节约50%  for(var i = 0;len = item.length i\u0026lt;len; i++){} 3.通过\u0008改变数组顺序来提高循环性能:通常数组顺序与要执行的任务无关，倒序循环是编程语言中的一种通用性能优化方案，\n // for循环  for(var i = items.length; i--){}  // while循环  var i= item.length; while(i--){}  // do-while  var j = items.length-1 ; do{}while(j--)  //以上控制条件只是简单的与0比较，控制条件从两次比较减少到一次，提高循环性能，\u0008一般可以提高50%-60%  优化后每次循环所经历的步骤  1. 一次比较操作，查看控制条件的计算是否为true(i === true)  2. 一次自减(i--)  3. 一次数值查找 (items[i])  4. 一次函数体执行  当复杂度为O(n)时，减少每次迭代的步骤次数是最有效的，当复杂度为大于O(n)时，建议着重减少迭代次数 减少迭代次数 #  duff‘s Device(\u0008达夫设备)\u0008是一种循环体展开技术，它使得一次迭代中实际执行了多次迭代。当循环次数超过1000的时候duff‘s Device的执行效率将明显提升，在500000次迭代中，其运行时间比 常规少70%\n条件语句 #   关于使用switch还是if-else，通常数量比较越大更倾向于使用switch而不是if-else。\u0008事实证明大多数情况下switch比if-else更快，当然是在一定数量的情况下。原因是当条件增加时if-else性能负担增加的程度比switch要多(大多数的语言对switch语句都采用了branch table(分支表)索引来进行优化，并且在switch语句比较值的时候使用全等===操作符，不会发生类型转换的消耗) 通过构建数组作为查找表来替代条件语句，随着数量的增大也几乎不会产生额外的性能开销  递归 #  潜在问题是终止条件不明确或者说缺少终止条件会导致函数长时间运行，使用户界面处于假死状态。并且还有可能遇到浏览器的调用栈大小限制\n 任何递归都能用迭代实现 使用Memoization技术优化递归的重复计算  是一种将函数返回值缓存起来的方法，Memoization 原理非常简单，就是把函数的每次执行结果都放入一个键值对(数组也可以，视情况而定)中，在接下来的执行中，在键值对中查找是否已经有相应执行过的值，如果有，直接返回该值，没有才 真正执行函数体的求值部分。很明显，找值，尤其是在键值对中找值，比执行函数快多了。 Fibonacci例子 //递归调用 function fibonacci(n){ if(n==0||n==1){  return n;  }  return fibonacci(n-1) + fibonacci(n-1); } //缓存优化 var fibonacci = function(){  if(!memfactorial.cache){  memfactorial.cache = {  0:1,  1:1  }  }   if(memfactorial.cache.hasOwnPrototype(n)){  memfactorial.cache[n] = n * fibonacci(n-1)  }   return memfactorial.cache[n] };     "},{"id":6,"href":"/draft/ssh/","title":"github 免登录","section":"Drafts","content":"github支持ssh公钥的登录,在github同步公钥后不再需要输入账号密码，就可以实现git的相关操作\n客服端生成公钥 #  \u0008在客服端执行 ssh-kengen -t rsa -C “email@address” 一直回车（期间可以输入验证串，那么以后也会输入该串配对验证，一般不需要）即可在生成公钥和私钥\ncd ~/.ssh 可以看到id_rsa.pub就是我们所生成的公钥\n# 推送到远程服务器 ssh-copy-id user@server 配置github #  添加公钥到github账号 使用网页登陆github，在settings–\u0026gt;ssh keys–\u0026gt;add key 把id_rsa.pub 里面的公钥复制到这类，title随便取一个名字就可以了\n测试账号 #  ssh git@github.com  Hi xxxx! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 表示连接成功 克隆项目 #  git clone git@github.com:username/projectname.git\n注意事项切记一定要采用git@github.com的ssh模式不然会报错\ngit设置全局用户名 #  git config \u0026ndash;global user.name \u0026ldquo;username\u0026rdquo;\ngit config \u0026ndash;global user.email \u0026ldquo;address@mail\u0026rdquo;\n"},{"id":7,"href":"/draft/high-javascript/data/","title":"数据存取","section":"高性能JavaScript","content":"作用域链 #  每一个javascript函数都可以表示为一个对象，更确切的说，是Function对象的一个实例，拥有可以编程访问的属性和一系列不能访问的内部属性，其中一个是[[Scope]]。内部属性[[scope]]包含了\u0008一个函数被创建作用域中对象的集合，那么这个集合被称为作用域链，它决定了那些能被函数访问。\n当函数被执行时会创建一个执行环境，每个执行环境都有自己的作用域，用于解析标识符，在函数的执行中每遇到\u0008一个变量都会经历一次标识符解析，会持续的在作用域链中去搜索匹配这个对象，正是这个过程影响了性能，\u0008正是由于标识符的解析过程，所以出现同名的变量那么第二个会覆盖第一个变量。\n局部变量 #  由于全局变量会在最远处，所以最好使用局部变量会更快。 由于很多全局变量比如document等，通过在函数局部声明变量来承载，会提高性能\nfunction test(){  links = document.getElementByTagName(\u0026#39;a\u0026#39;)  document.getElementById(\u0026#39;click\u0026#39;).onClick = function(){   }  // 以上的案例会搜索全局变量document两次  var dc = document  links = dc.getElementByTagName(\u0026#39;a\u0026#39;)  dc.getElementById(\u0026#39;click\u0026#39;).onClick = function(){   }  // 以上案例智慧搜索一次全局变量document，解析\u0008标识符的路径会更短 } 闭包 #  由于在闭包存在的情况下，执行环境无法被销毁，也就是说会消耗更多的内存。在使用闭包的情况下会创建一个执行环境与属性[[scope]]中所引用的相同作用域对象一起被初始化；在闭包中用到的标识符，位于作用域链的第一个作用域之后，在频繁的跨作用域访问标识符，会带来性能损耗\n对象成员 #  javascript是基于原型。原型是对象的基础；对象通过内部属性_proto_绑定其成员变量。当函数或者对象读取或者执行的时候，会在当前实例搜索变量，没有则继续搜索原型对象，可以通过hasOwnProperty、in操作符来判断当前实例是否具有该属性或者方法。正是这个逐级搜索的过程严重的拖慢了访问成员变量的时间\n1. 嵌套成员:对象中包含其他对象，例如window.location.href每次遇到点操作符，嵌套成员会导致javascript引擎搜索所有对象成员，嵌套的越深读取速度就越慢，执行location.href\u0008总会比window.location.href要快。（在大部分浏览器中点操作和括号表示法没有明显的区别，只有Safari中点操作始终比括号表示法更快）\n2. 缓存对象成员:在同一函数中没必要多次读取同一个对象成员。通常来说在函数中需要多次读取一个对象属性，最佳做法是局部变量缓存，降低多次查找带来的开销，特别是在处理嵌套成员的时候。不要再同一函数下多次查找一个对象，除非这个对象值变化了\n小结 #   访问字面量和局部变量\u0008速度最快，访问数组和对象成员相对会慢 局部变量处于顶端起始位置会比跨作用域访问更快；而全局变量处于作用域末端，访问速度最慢 避免使用with，它会改变\u0008执行环境的作用域链；try-catch中的catch也会改变执行环境作用域链，因此需要小心使用 嵌套成员明显影响性能，尽可能少用 通常来说使用缓存变量到函数的局部环境，会改善javascript性能  "},{"id":8,"href":"/draft/high-javascript/load-and-execute/","title":"加载与执行","section":"高性能JavaScript","content":"概述 #  多数浏览器使用单一进程来处理用户界面（UI）刷新和javascript脚本的执行，所以同一时间只能做一件事，js执行时间越久，浏览器等待响应时间就越长。script标签的每次出现，页面会等待脚本的解析和执行；不管是和内联好还是外链，页面的下载和渲染都必须等待脚本 的执行。这个过程中的页面交互式完全阻塞的。\n脚本位置\u0008 script标签位置 #   浏览器在解析到body标签之前不会渲染任何页面，如果把脚本放在顶部，通常表现为页面空白 每个脚本必须等到前一个脚本下载完成、\u0008执行完成才会开始下载和执行；瀑布图中显示的下载间隔刚好是前一个脚本的\u001c执行时间   结论：推荐将所有的\u0026lt;script\u0026gt;标签尽可能的放到标签的底部，以尽量减少对整个页面下载的影响  组织脚本 #   由于每个\u0026lt;script\u0026gt;标签的初始下载都会阻塞页面的渲染，减少页面包含的\u0026lt;script\u0026gt;标签有利于改善性能； 考虑到http\u0008的网络消耗，下载单个100k会比4个25k要快同时浏览器解析html页面每遇到一个脚本标签，都会因为执行脚本导致一定的延迟，\u0008因此脚本的数量也需要限制。 （Steve Souders）把内联的脚本放在\u0026lt;link\u0026gt;标签之后,也会导致页面阻塞去等待样式表的下载。（目的：\u0008确保内嵌脚本在执行时能或得最精准的样式信息），建议永远不需要把内嵌脚本放在\u0026lt;link\u0026gt;标签之后 脚本合并：通常将\u0008多个文件合并成一个文件下载，比如Yahoo的合并处理器  1.静态资源打包：服务器将多个文件合并成一个文件 \u0026lt;script src=\u0026#34;http://a.tbcdn.cn/??s/kissy/1.1.6/kissy-min.js,p/global/1.0/global-min.js,p/et/et.js?t=2011092320110301.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 针对上面这个案例，那么服务器端你在这个请求的接口里，根据js参数的值，把a.js到e.js的内容读取出来，再合并成一个文件（一般同时还会压缩，比如去空格，比如缩短变量名等），输出到客户端。如果服务器端再加上缓存，那可能连合并都不需要了。这样页面加载速度会快非常多。比较常用的js打包工具有google的google closure，css用yui compressor。 无阻塞脚本 #  核心在于页面加载完成后才加载javascript代码，意味着window对象的load事件触发后在加载脚本\n 并行下载\u0026lt;script\u0026gt;标签在下载外部资源不会阻塞其他的\u0026lt;script\u0026gt;标签。虽然脚本的\u0008下载过程不会相互影响，但是页面仍然会等待所有的脚本下载并执行才能继续。 扩展属性（共同点都是并行下载）  defer:（html4）指明本元素所包含的脚本不会修改dom\u0008，代码可以安全的延迟执行（只有IE支持），该属性会在并行下载后等待页面完成后执行；任何带有defer属性的javascript文件下载时，它不会阻塞浏览器的其他进程，因此这类文件可以与页面其他资源并行下载(仅当src属性声明时才生效) sync:（html5）加载完成后自动执行     动态脚本元素 #  动态添加脚本元素到页面，使用动态脚本下载，返回的代码通常会立即执行\nfunction loadScript(url,callback){  var script = document.createElement(\u0026#39;script\u0026#39;)  script.type = \u0026#39;text/javascript\u0026#39;  if(script.readyState){  // 兼容IE  script.onreadystatechange = function(){  if(script.readyState==\u0026#39;loaded\u0026#39;||script.readyState==\u0026#39;complete\u0026#39;){  script.onreadystatechange = null  callback()  }  }  }else{  script.onload = function(){  callback()  }  }   script.url = url  document.getElementsByTagName(\u0026#39;head\u0026#39;)[0].appendChild(script) } // 调用 将代码放到body闭合标签前；1）确保js执行不会阻塞页面；2）避免监听其他事件比如window.onload loadScript(\u0026#39;test.js\u0026#39;,function(){  // do something }) 可以使用YUI3、LazyLoad、LABjs来完成类似的工作 小结 #   将所有脚本放在页面的底部加载执行 合并脚本 无阻塞下载  defer属性、sync属性 动态脚本元素 xhr下载脚本注入    "},{"id":9,"href":"/docs/notes/git/","title":"Git","section":"一些杂记","content":" 本地与远程的分支列表不一致(在gitlab管理界面删除分支之后) git remote update origin --prune  error: failed to push some refs to git pull --rebase origin master git push -u origin master  拉取git子模块 git submodule update --init --force   "}]