[{"id":0,"href":"/draft/interview/get-post/","title":"GET和POST的区别","section":"面试","content":"GET和POST的区别 #   GET请求在浏览器回退和刷新时是无害的，而POST请求会告知用户数据会被重新提交； GET请求可以收藏为书签，POST请求不可以收藏为书签； GET请求可以被缓存，POST请求不可以被缓存，除非在响应头中包含合适的Cache-Control/Expires字段，但是不建议缓存POST请求，其不满足幂等性，每次调用都会对服务器资源造成影响； GET请求一般不具有请求体，因此只能进行url编码，而POST请求支持多种编码方式。 GET请求的参数可以被保留在浏览器的历史中，POST请求不会被保留； GET请求因为是向URL添加数据，不同的浏览器厂商，代理服务器，web服务器都可能会有自己的长度限制，而POST请求无长度限制； GET请求只允许ASCII字符，POST请求无限制，支持二进制数据； GET请求的安全性较差，数据被暴露在浏览器的URL中，所以不能用来传递敏感信息，POST请求的安全性较好，数据不会暴露在URL中； GET请求具有幂等性(多次请求不会对资源造成影响)，POST请求不幂等； GET请求一般不具有请求体，请求中一般不包含100-continue 协议，所以只会发一次请求，而POST请求在发送数据到服务端之前允许双方\u0026quot;握手\u0026quot;，客户端先发送Expect:100-continue消息，询问服务端是否愿意接收数据，接收到服务端正确的100-continue应答后才会将请求体发送给服务端，服务端再响应200返回数据。  "},{"id":1,"href":"/draft/readbook/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/","title":"浏览器渲染","section":"读书小记","content":"Introduction #  主要描述浏览器的渲染\n一个页面页面进程 #   浏览器进程  界面显示、用户交互、子进程管理   渲染进程  核心将html、css、JavaScript转换成用户可以交互的网页 排版引擎blink JavaScript引擎V8   GPU进程  最初实现CSS3效果 最后chrome的UI和网页都是采用GPU来绘制   网络进程  主要负责网络资源加载   插件进程  插件的运行隔离    导航流程 #  （用户发出URL请求到页面开始解析的过程，叫做导航）\nURL请求过程 #  浏览器进程 #  用户输入 #   如果是搜索内容，会使用搜索引搜索 如果是URL，会根据URL规范合成完整的协议  网络进程 #   浏览器进程通过 （IPC）将请求交给网络进程 网络进程首先会检查本地储存 进入网络请求流程  DNS解析  获取IP 如果是https请求，还需要 建立TLS   收到响应头和响应行，就开始解析响应头的内容 如果响应状态码是301、302 从响应头的 Location 字段里面读取重定向的地址 响应数据类型处理 浏览器根据content-type来决定如何显示响应内容    渲染进程 #    打开一个新页面采用的渲染进程策略就是：通常情况下，打开新的页面都会使用单独的渲染进程；\n  如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；\n  如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。\n\t# 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。 \t# 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。 \t# 创建布局树，并计算元素的布局信息。 \t# 对布局树进行分层，并生成分层树。 \t# 为每个图层生成绘制列表，并将其提交到合成线程。 \t# 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。 \t# 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。 \t# 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。 ``\n  提交文档 #   将网络进程收到的html数据，交给渲染进程的过程 首先当浏览器 进程收到网络进程的响应头，便向浏览器发起“提交文档” 渲染进程收到提交文档消息后，会和网络进程建立传输数据通道 等文档传输完成，渲染进程会返回“确认提交”的消息给浏览器进程 浏览器进程收到“确认消息”，会更新浏览器界面  渲染阶段 #   构建 DOM: 将html转换成树形结构 样式计算 将css文本转换成styleSheets。 转换属性值，使标准化 计算每个结点的样式  继承 层叠    布局阶段 #   计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。 创建布局树  遍历所有可见节点 ，并把这些节点加到 布局树中 布局计算   分层  为特定的节点生成专用的图层，并生成一颗图层树 拥有层叠上下文属性的元素会被提升为单独的一层。 第二点，需要剪裁（clip）的地方也会被创建为图层。   绘制  待绘制列表   分块  当绘制列表准备好以后，主线程会将它提交给合成线程 合成线程会将图层划分为图块（tile）   栅格化  将图块转换为位图 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。 最终生成位图都是在GPU中完成的   合成  一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。    其他 #    重排\n 更新了元素的几何属性（重排） 重排需要更新完整的渲染流水线，所以开销也是最大的。 width、height、margin、border    重绘\n 更新元素的绘制属性（重绘） 重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。 color、border-style、background、text-decoration、outline    合成\n 既不要布局也不要绘制的属性 transform   "},{"id":2,"href":"/draft/readbook/hash_history/","title":"hash和history的差异","section":"读书小记","content":"Introduction #  浏览器导航\n#锚点 #  本来的用途是跳转到页内锚点。在URL中指定的是页面中的一个位置\n 改变#后面的参数不会触发页面的重新加载，但是会留下历史记录 单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页 window.location.hash这个属性可读可写。读取时，可以用来判断网页状态是否改变；写入时，则会在不重载网页的前提下，创造一条访问历史记录。 onhashchange事件,这是一个HTML 5新增的事件，当#值发生变化时，就会触发这个事件  hash #  地址栏中的#，不会包含在http请求中\nhistory #  利用HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法（应用于浏览器的历史记录栈），执行改API不会向后端发送请求\n history模式需要后端配合，刷新的时候需要后端返回根目录由前端导航 window.location.hash这个属性可以对URL中的井号参数进行修改  其他 #   hash模式下，使用锚点，会导致url变化，但是页面不会刷新； hash模式下，使用JS来计算滚动。 "},{"id":3,"href":"/draft/readbook/http/","title":"http","section":"读书小记","content":"Introduction #  http 相关的基本概念\n网络基本模型 #   从上至下依次(5层基本模型)   应用层（为用户的应用进程提供网络通信服务）  http、ftp、smtp、dns   传输层  tcp、udp   网络层  IP   链路层 物理层  TCP 三次握手、四次挥手 #  概念 #  传输控制协议，是一种可靠的传输层协议，具有确认窗口，重传，拥塞机制；IP协议号为6。TCP连接时全双工 参考链接\n常用场景： #   TCP：HTTP、ftp、smtp UDP：语言、视频  三次握手的意义 #   为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。  过程 #   第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack (number )=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了  四次挥手 #   原理：TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。  Http #  概念 #   HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。  主要特点 #   简单快速 灵活 无连接（每次连接只处理一个请求） 无状态（对事物没有记忆功能）  常见状态码 #   100 指示信息\u0026ndash;表示请求已接收，继续处理 2xx 成功- 表示请求已经接受、理解 3xx 重定向- 要完成请求必须要进行进一步操作 4xx 客服端错误- 请求语法错误或请求无法实现 5xx 服务端错误- 服务端未能实现合法请求 200 OK //客户端请求成功 301 // 永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 304 // （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。（未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden //服务器收到请求，但是拒绝提供服务 404 Not Found //请求资源不存在，eg：输入了错误的URL 500 Internal Server Error //服务器发生不可预期的错误 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常   Https #  概念 #  HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密\n为什么需要HTTPS #   http使用明文传输；（导致数据泄露、数据篡改、流量劫持、钓鱼攻击） 无法证明报文的完整性，所以可能遭篡改 HTTP协议中的请求和响应不会对通信方进行确认（钓鱼欺诈）  https优势 #   数据隐私性： 内容加密，每个连接生成唯一的加密秘钥  实现：加密（对称加密、非对称加密）   数据完整性： 内容经过完整性校验  实现：数字签名（证书颁发机构（Certificate Authority，简称CA）   身份认证： 第三方无法伪造服务端（客服端）身份  实现：数字证书（数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。）    区别 #   传输信息安全性不同  http协议：是超文本传输协议，信息是明文传输 https具有安全的ssl加密传输协议，为浏览器和服务器通信加密   连接方式不同  http无状态连接（事务处理无记忆功能） https： 由ssl+http协议构建的可进行加密传输，身份认证的网络协议   端口不同  http协议：使用的端口是80。 http协议：使用的端口是80。   证书不同  http，免费 https 需要cs申请证书，一般需要购买    安全的原因 #   参考链接\n HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。 https主要作用 对数据进行，并建立一个信息安全通道，保证传输过程中的数据安全 对网站服务器进行真实身份认证  注意 #   HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。 "},{"id":4,"href":"/docs/notes/vim/","title":"vim常用命令","section":"一些杂记","content":"Introduction #  主要记录vim使用过程中的快捷键\n输入模式 #   i 切换输入模式 a 光标后插入 A 光标行尾插入 i 光标前插入 I 光标行首插入 o 打开向下打开新行 O 打开向上打开新行  esc #   退出模式  保存 #   w wq wq！ q! wq! (root 文件所有者可以操作)  快捷键 #   h 向左 j 向下 k 向上 l 向右 gg 文件头 G 文件尾  快速跳转 #   ^ 行首 $ 行尾 :n 跳到指定n 行 x 删除一个字母 xn 删除P指定n个字母 dd 删除单行 ndd 删除n行  剪切/粘贴/撤销 #   p 粘贴光标上面 P 粘贴光标下面 :n1,n2d 剪切多行 n行号 dG 先执行gg文件头 从光标删除到文件尾 u 撤销 一直到文件打开状态 control+r 反撤销  替换 #   r 替换单个 R 替换模式  查找 #   ? 光标向上 / 光标向下 n 下一个 N 上一个  其他 #   r 导入其他文件内容 :r abc.txt !命令 在vim执行系统命令 r !命令 导入命令的结果 map 自定义快捷键 o 上下打开多个文档  control+w 上下箭头 切换文件   O 左右打开多个文档  control+w 左右箭头 切换文件   "},{"id":5,"href":"/draft/readbook/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/","title":"浏览器缓存","section":"读书小记","content":"Introduction #   参考链接\n用户行为对缓存的影响\n   用户操作 Expires/Cache-Control Last-Modied/Etag     地址栏回车 有效 有效   页面链接跳转 有效 有效   新开窗口 有效 有效   前进回退 有效 有效   F5刷新 无效 有效   Ctrl+F5强制刷新 无效 无效    缓存过程 #   文件请求服务器 首先根据存入的标识 决定是否使用缓存 带上浏览器缓存的标识请求服务器 服务器返回相应的缓存字段存入浏览器  强缓存 #    特点：强缓存是不需要发送HTTP请求的\n  Expires：Expires的值为一个绝对时间，是GMT格式（GMT时间就是英国格林威治时间，GMT时间 = 北京时间 - 8小时）的时间字符串，指的是缓存的具体过期时间，它描述的是时刻，是一个时间点\n  Expires 是依赖于客户端系统时间，当修改了本地时间后，缓存可能会失效\n  Cache-Control： Cache-Control 设置 max-age；表示缓存的最长时间是多少秒，定义的是时间的长短，它描述的是时间，表示的是一段时间间距，是一个相对时间\n max-age(表示缓存内容在 xx秒后消失) no-cache(要根据协商缓存是否需要缓存客户端) no-store(所有内容都不会被缓存) public(所有内容都将被缓存包括客户端和代理服务器) private(所有内容只有客户端可以缓存) s-maxage(只用于共享缓存和max-age效果一样,只是max-age 用于普通缓存)    注意：Cache-Control 与 Expires 可以在服务端配置同时启用，也就是说在 response header 中，Expires 和Cache-Control 是可以同时存在，当它们同时启用的时候Cache-Control 优先级更高。\n  协商缓存 #   特点： 发送请求之前, 会先检查一下强缓存, 如果命中直接使用，否则就进入下一步;  前提是cache-control标识的 max-age 过期了，或者设置了协商缓存   Last-Modified / If-Modified-Since  Last-Modified 表示被请求资源在服务器端的最后一次修改时间，当再次请求该资源的时候，浏览器的request header中会带上If-Modified-Since，向服务器询问该资源是否有更新。   ETag/If-None-Match  每次文件修改后服务端那边会生成一个新的 ETag ，是一个唯一文件标识符，当再次请求该资源时候，浏览器的request header中会带上If-None-Match ，这值就是之前返回的ETag ，把这个值发送到服务器，询问该资源 ETag 是否变动，有变动的话，说明该资源版本需要更新啦，客户端不能继续用缓存里的数据了。    Service Worker #   Service Worker本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API。 Service Worker的本质是一个Web Worker，它独立于JavaScript主线程，因此它不能直接访问DOM，也不能直接访问window对象，但是，Service Worker可以访问navigator对象，也可以通过消息传递的方式（ postMessage）与JavaScript主线程进行通信。  Service Worker是一个网络代理，它可以控制Web页面的所有网络请求。 Service Worker具有自身的生命周期，使用好Service Worker的关键是灵活控制其生命周期。   作用  用于浏览器缓存 实现离线Web APP 消息推送   "},{"id":6,"href":"/draft/readbook/design-pattern/","title":"简单设计模式","section":"读书小记","content":"简单学习相关设计模式（大话设计模式），以下是概念描述；具体实例参考\n 实例代码\n依赖倒转 #   是面向对象设计的标志，即程序中所有的依赖关系都是终止与抽象类或者看接口  迪米特法则 #   如果两个类不必彼此直接通信，那么这两个类就不该发生直接的相互作用。如果其中一个类需要调另一个类的某一个方法的话，可以通过第三者转发这个应用  封装 #   业务逻辑和界面逻辑分开，耦合度降低  单一职责链原则（SRP） #   就一个类而言，应该仅有一个使它变化的原因  开放封闭原则 #   可以扩展，但不能修改  依赖倒转原则 #   抽象不应该依赖细节，细节应该依赖于抽象(针对接口编程，不要对实现编程) 高层模块不应该依赖底层模块，两个都应该依赖抽象 抽象不应该依赖细节，细节应该依赖抽象[ASD]  里氏替换原则 #   子类型必须能够替换它们的父类型[ASD]  合成/聚合复用原则 #   尽量使用合成聚合，尽量不要使用类继承  设计模式 #  策略模式 #   策略模式指的是定义一系列的算法，并且把它们封装起来，但是策略模式不仅仅只封装算法，我们还可以对用来封装一系列的业务规则，只要这些业务规则目标一致，我们就可以使用策略模式来封装它们  装饰模式 #   动态地给一个对象添加一些额外的职责  代理模式 #   为其他对象提供一种代理以控制对这个对象的访问  外观模式 #   为子系统中的一组接口提供一致的界面，此模式定义一组高层接口，使得子系统更加易于使用  建造者模式 #   一个复杂对象的构建与它的表示分离，使得同样的构造过程可以构建不同的表示  抽象工厂模式 #   提供一个创建一系列相关或相互依赖对象接口，而无需指定他们具体的类  状态模式 #   当一个对像的内在状态改变时允许改变其行为，这个对象看起来是改变了其类  组合模式 #   将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性  迭代器模式 #   提供一种方法顺序访问对象的各个元素，而又不暴露该对象的内部表示  桥接模式 #   将抽象部分与它的实现部分分离，使他们都可以独立地变化  命令模式 #   将一个请求封装为一个对象，从而使你可用不同的请求对客服进行参数化，对请求排队或者记录日志，以及支持可撤销的操作  职责链模式 #   使多个对象都有机会处理请求,从而避免请求的发送者和接受者这间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，知道有一个对象处理它为止  中介者模式 #   用一个对象来封装一系列的对象交互。  享元模式 #   运用共享技术有效的支持大量细粒度的对象  解释器模式 #   给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该该表示解释语言中的句子 "},{"id":7,"href":"/draft/readbook/function/","title":"函数式编程","section":"读书小记","content":"函数式编程 #  使用函数来抽象作用在数据之上的控制流与操作，从而在系统中消除副作用并减少对状态的改变 函数式编程指创建不可变的程序，通过消除外部可见的副作用，来对纯函数的声明式的求值过程\n优点\n 任务分解为简单函数 流式调用链来处理 响应式降低事件驱动代码的复杂性  声明式编程 #    命令式编程: 具体的告诉计算机如何执行某个任务;旨在尽可能的提高代码的无状态和不变性\nlet array = [1, 2, 3, 4, 5, 6, 7, 8, 9] for (let i = 0; i \u0026lt; array.length; i++) {  array[i] = Math.pow(array[i],2) }   声明式编程：将程序的描述和求值分开，更加关注于如何用表达式来描述程序逻辑，而并不一定需要指明控制流或者状态的变化\narray.map(num =\u0026gt; Math.pow(array[i], 2))   纯函数 #  没有副作用和状态变化的函数\n 仅取决于输入，而不依赖于任何在函数求值期间或者调用间隔可能变化的隐藏状态和外部状态 不会造成超出其作用域的变化；例如全局参数或者引用传递  常见副作用\n 改变全局变量 改变函数参数初始值 处理用户输入 抛出异常 打印，记录日志 查询html文档、浏览器cookie等  引用透明：\n引用透明 #  如果一个函数对于相同的输入，始终产生相同的结果，那么就说他是引用透明的\n不可变性 #  创建之后不能更改的数据\njavascript 函数 #  一等函数 #  function multiplier(a,b) {  return a*b } let multiplier = function (a, b) {  return a * b } let multiplier = (a, b) =\u0026gt; a * b let multiplier = new Function(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;return a*b\u0026#39;) 高阶函数 #  作为函数的参数传递，或者由其他函数返回，这些函数被称为高阶函数\nlet multiplier = (a, b) =\u0026gt; a * b  function applyOperation(a,b,opt) {  return opt(a,b) } applyOperation(2,3,multiplier) // 6  function add(a){  return function(b){  return a+b  } }  add(3)(3) // 6 闭包和作用域 #  闭包 #  闭包是一种能够在函数声明过程中将环境信息与所属函数绑定不再一起的数据结构 基于函数声明的文本位置，因此也被称为围绕函数定义的静态作用域或词法作用域\n函数闭包\n 函数的所有参数 外部所有变量  闭包的实际应用 #    模拟私有变量\n  异步服务调用\n  创建人工块作用域变量\n  模拟私有变量 #  一些库或者模块使用闭包来隐藏整个模块的私有方法和数据。被称为模块模式，采用了立即执行函数（IIFE）\nvar myModule = (function (ex) {  let _privateVar = \u0026#39;私有变量\u0026#39;   ex.method = function () {   } }) (myModule||{}) 异步服务端调用 #  提供回调函数来处理请求\n作用域 #  全局作用域 #  任何对象和在脚本最外层声明的（不在函数中声明）变量都是全局作用域的一部分\n函数作用域 #  任何在函数中声明的任何变量都是局部且外部不可见的。\n作用域机制\n 首先检查变量的函数作用域 如果不是局部作用域内，逐层向外检查各词法作用域，直到全局作用域 如果无法找到变量引用，那么JavaScript会返回undefined  伪块作用域 #  with语句与块作用域类似，但是不被建议使用，在严格模式下被禁止\n有歧义的循环计数器\nvar arr = [1, 2, 3, 4]  function processArr() {  function multipleBy10(val) {  i = 10 // 导致 i 被改写  return i * val  }  for (var i = 0; i \u0026lt; arr.length; i++) {  arr[i] = multipleBy10(arr[i])   }  return arr } console.log(processArr()); // [10,2,3,4] let、const解决了置顶问题\n"},{"id":8,"href":"/draft/javascript/reflect-proxy/","title":"代理和反射","section":"javascript","content":"代理(Proxy)是一种可以拦截并改变底层JavaScript引擎的操作包装器，在新语言中通过它暴露内部运作对象，从而让开发者可以创建内建对象\n代理和反射 #  代理 #  调用new Proxy()可以创建代替其他目标对象的代理，虚拟化了目标，使其二者看起来功能一致，代理可以拦截JavaScript引擎内部目标的底层对象操作，这些底层操作被拦截后会触发响应特定操作的陷阱函数。\n用Proxy构造函数创建代理需要两个参数： 目标(target)和处理程序(handler)，处理程序定义一个或者多个陷阱的对象，除去专门特定的操作定义外，其余操作均使用默认特性\nlet t = {} let p = new Proxy(t, {}) p.name = \u0026#39;hello proxy\u0026#39; console.log(p); // { name: \u0026#39;hello proxy\u0026#39; } console.log(t); // { name: \u0026#39;hello proxy\u0026#39; } 反射 #  反射API以Reflect对象的形式出现，对象中的方法默认特性相应的底层操作一致。而每一个代理陷阱会对应一个命名和参数都相同的Reflect方法(其实就是每个代理陷阱都会对应一个Reflect api接口供覆写JavaScript底层操作)\n代理陷阱特性\n   代理陷阱 覆写的特性 默认特性     get 读写一个属性值 Reflect.get()   set 写入一个属性 Reflect.set()   has in操作 Reflect.has()   deleteProperty delete操作符 Reflect.deleteProperty()   getAPrototypeof Object.getAPrototypeof () Reflect.getAPrototypeof ()   setAPrototypeof Object.setAPrototypeof () Reflect.setAPrototypeof ()   isExtensible Object.isExtensible() Reflect.isExtensible()   preventExtensions Object.preventExtensions() Reflect.preventExtensions()   getOwnPropertyDescriptor Object.getOwnPropertyDescriptor() Reflect.getOwnPropertyDescriptor()   defineaProperty Object.defineaProperty() Reflect.defineaProperty()   ownKeys Object.keys() 、 Object.getOwnPropertyNames()和 Object.getOwnPropertySysmbols() Reflect.ownKeys()   apply 调用一个函数 Reflect.apply()   construct 用new调用一个函数 Reflect.construct()    set陷阱验证(设置属性) #  set陷阱接受4个参数：\n trapTarget 用于接受属性(代理目标)的对象 key 要写入的属性键(字符串或者symbol类型) value 被写入属性的值 receiver 操作发生的对象(通常是代理)  Reflect.set是set陷阱对应的反射方法和默认特性，\nlet target = { \tname:\u0026#39;target\u0026#39; } let proxy = new Proxy(target, {  // receiver 等同于 proxy \tset (trapTarget, key, value, receiver) { \tif (!trapTarget.hasOwnProperty(key)) { \tif (isNaN(value)) { \tthrow new TypeError(\u0026#39;属性必须是数字\u0026#39;) \t} \t} \treturn Reflect.set(trapTarget, key, value, receiver) \t} }) proxy.count = 1 console.log(target.count); // 1 console.log(proxy.count); // 1 proxy.anotherName = \u0026#39;proxy\u0026#39; // TypeError: 属性必须是数字 get陷阱验证(获取属性) #  JavaScript中的困惑行为，当读取一个不存在对象上的属性的时候，会返回undefined，而不是报错\nlet target = {} console.log(target.name) // undefined 可以通过get陷阱来检测，读取属性是否存在\n接受三个参数\n trapTarget 目标对象 key 读取的属性值 receiver 操作发生的对象  let proxy = new Proxy({},{ \tget(trapTarget, key, receiver){ \tif(!(key in receiver)){ \tthrow new TypeError(`属性${key}不存在`) \t} \treturn Reflect.get(trapTarget,key,receiver) \t} }) proxy.name = \u0026#39;proxy\u0026#39; console.log(proxy.name) // proxy proxy.nam // TypeError: 属性nam不存在 has陷阱(in 操作符) #  has陷阱覆写的特性是in操作符；in操作符的作用是来检测给定对象中是否包含某个属性，如果自有属性或原来属性匹配这个名称或Symbol 就返回true\nlet target = { \tvalue:42 } console.log(\u0026#39;value\u0026#39; in target) // true console.log(\u0026#39;toString\u0026#39; in target) // true console.log(\u0026#39;name\u0026#39; in target) // false 使用in操作符会调用has陷阱\n trapTarget Key  let target = { \tvalue:42, \tname: \u0026#39;target\u0026#39; } let porxy = new Proxy(target,{ \thas(trapTarget,key){ \tif(key===\u0026#39;value\u0026#39;){ \treturn false \t} \treturn Reflect.has(trapTarget,key) \t} }) console.log(\u0026#39;value\u0026#39; in porxy) // false console.log(\u0026#39;toString\u0026#39; in porxy) // true console.log(\u0026#39;name\u0026#39; in porxy) // true deleteProperty陷阱(delete ) #  delete可以从对象中移除属性，成功返回true，反正返回false； 在严格模式下删除一个不可配置(noncoonfigurable)属性则会导致程序抛出错误，而非严格模式下只会返回false\nlet target = { \tname:\u0026#39;target\u0026#39;, \tvalue:42 }  Object.defineProperty(target,\u0026#39;name\u0026#39;,{configurable:false}) console.log(\u0026#39;value\u0026#39; in target); // true console.log(delete target.value); // true console.log(\u0026#39;value\u0026#39; in target); // false  console.log(\u0026#39;name\u0026#39; in target); // true // 严格模式 \u0026#39;use strict\u0026#39;; console.log(delete target.name); // TypeError: Cannot delete property \u0026#39;name\u0026#39; of #\u0026lt;Object\u0026gt; deleteProperty陷阱\n trapTarget key  let target = { \tname:\u0026#39;target\u0026#39;, \tvalue:42 }  let proxy = new Proxy(target, { \tdeleteProperty(traptarget, key){ \tif(key===\u0026#39;value\u0026#39;){ \treturn false \t} \treturn Reflect.deleteProperty(traptarget,key) \t} })  console.log(\u0026#39;value\u0026#39; in proxy); // true console.log(delete proxy.value); // false console.log(\u0026#39;value\u0026#39; in proxy); // true 原型代理陷阱 #  "},{"id":9,"href":"/draft/javascript/promise/","title":"promise","section":"javascript","content":"Javascript引擎基于单线程事件循环，同一时间只运行一个代码块运行；反之多线程是运行多个代码块同时执行。\n所以JavaScript需要跟踪即将运行的代码，将这些代码放在一个任务队列中，当代码准备执行的时候都会添加到任务队列中，当一段代码执行结束，事件循环会执行队列下一个任务。队列中的任务会从第一个一直执行到最后一个\n  事件模型：用户点击键盘或者触发类似onclick事件，会想任务队列增加一个任务来响应用户的操作，直到事件触发才执行事件处理程序，这是JavaScript中最基础的异步编程\n  回调模式：Nodejs通过普及回调函数拉改进异步编程模型，异步代码会在未来某个时间执行，回调模式中被调用的函数式作为蚕食传入的。\n  Promise基础 #  promise相当于一个异步操作结果的占位符，它不会去订阅一个事件，也不会传递一个回调函数给目标，而是返回一个Promise。\n// readFili承诺将来某个时刻完成 let promiss = readFile(\u0026#39;example.txt\u0026#39;) 创建Promise #  let fs = require(\u0026#39;fs\u0026#39;) function readFile () { \treturn new Promise((resolve, reject) =\u0026gt; { \tfs.readFile(\u0026#39;filename\u0026#39;, {encoding:\u0026#39;utf8\u0026#39;},function(err, con) { \tif (err) { \treject(err) \treturn \t} \tresolve(con) \t}) \t}); } Promise.resolve #  只接受一个参数，并返回一个完成态的Promise；如果传入的是一个Promise，那么换个Promise会被立即返回\nlet p1 = Promise.resolve(42) p1.then(value=\u0026gt;console.log(value)); // 42 Promise.reject #  只接受一个参数，并返回一个拒绝的Promise；如果传入的是一个Promise，那么换个Promise会被立即返回\nlet p1 = Promise.reject(42) p1.catch(value=\u0026gt;console.log(value)); 生命周期 #    pending 进行中，操作尚未完成，所以是未处理，一旦操作结束会进入到下一个状态\n  Fulfilled 异步操作完成\n  Rejected 异步操作未能完成\n  内部属性[[PromiseState]]被用啦表示3种状态；\u0026ldquo;pending\u0026rdquo;、\u0026ldquo;fulfilled\u0026rdquo;、\u0026ldquo;rejected\u0026rdquo;。这个属性不暴露，所以不能通过编程的方式检测promise状态，只有当promise状态改变，通过then方法拉采取特定行动\n全局拒绝处理 #  浏览器环境的拒绝处理：\n在浏览器中可以通过监听window事件来识别未处理的拒绝\nlet rejected; window.onunhandledrejection = function(event){  console.log(event.type); // unhandledrejection  console.log(event.reason.message); // Explosion  console.log(rejected === event.promise);\t// true } window.onrejectionhandled = function(event){  console.log(event.type);  console.log(event.reason.message);  console.log(rejected === event.promise);\t} rejected = Promise.reject(new Error(\u0026#34;Explosion\u0026#34;)) Nodejs环境的拒绝处理:\n在node中处理promise拒绝时候会触发processs上的事件\n unhandleRejection 在一个事件循环中，当promise被拒绝，并且没有提供相应拒绝程序的时候调用 rejectionHandled 在一个事件循环后，当promise被拒绝，并且没有提供相应拒绝程序的时候调用  let rejected;  process.on(\u0026#39;unhandledRejection\u0026#39;, function(reason, promise){  console.log(reason); // \u0026#39;Explosion\u0026#39;  console.log(rejected === promise) true })  rejected = Promise.reject(new Error(\u0026#34;Explosion\u0026#34;)) Promise 串联 #  每次调用then方法或者catch方法实际会创建并返回另一个promise，只有当第一个完成或者被拒绝后，第二个才会被解决\n let p1 = new Promise((resolve, reject) =\u0026gt; { \tresolve(42) }); p1.then(value =\u0026gt; { \tconsole.log(value); }).then(() =\u0026gt; { \tconsole.log(\u0026#39;finish\u0026#39;);\t}).catch(err =\u0026gt; { \tconsole.log(err); }) // 42 // finish  let p1 = Promise.resolve(1)  let px = function name(params) {  return new Promise((resolve, reject)=\u0026gt;{  setTimeout(()=\u0026gt;{  resolve(2)  },2000)  }) } let arr = [px, undefined]  arr.unshift((value)=\u0026gt;{  console.log(value, \u0026#39;3==\u0026#39;);  return 3 },(value)=\u0026gt;{  console.log(value, \u0026#39;4==\u0026#39;);  return 4 }) arr.push((value)=\u0026gt;{  console.log(value, \u0026#39;5==\u0026#39;);  return 5 },(value)=\u0026gt;{  console.log(value, \u0026#39;6==\u0026#39;);  return 6 })  while (arr.length) {  p1 = p1.then(arr.shift(), arr.shift()) } // 1 3== // 等待 2s 后 // 2 5== promise链的返回值，下一个promise会在上一个完成之后才会执行； 如果在完成处理的程序中返回值，则可以沿着这条链继续传递数据\n let p1 = new Promise((resolve, reject) =\u0026gt; { \tresolve(42) }); p1.then(value =\u0026gt; { \tconsole.log(value); \treturn value +1 }).then((value) =\u0026gt; { \tconsole.log(value);\t}).catch(err =\u0026gt; { \tconsole.log(err); }) //42 // 43 同样错误也可以返回值继续传递，在必要的时候，即使其中一个promise失败也能恢复整个promise链的执行\nlet p1 = new Promise((resolve, reject) =\u0026gt; { \treject(42) }); p1.catch(value =\u0026gt; { \tconsole.log(value); \treturn value+1 }).then(value =\u0026gt; { \tconsole.log(value); }) // 42 //43 Promise.all #  接受一个参数，并返回一个promise，该参数是一个含有多个受监视的Promise对象（比如数组），只有当所有Promise都被解决后返回的Promise才会被解决，只有当可迭代对象中所有的Promise都被完成返回的Promise才会被完成。\n被解决的值是按照顺序储存的，可以根据每个结果来匹配Promise\n所有传入的Promise只要一个被拒绝，那么返回的Promise不会等到都完成，而是立即拒绝\nlet p1 = Promise.resolve(42) let p2 = Promise.resolve(43) let p3 = Promise.resolve(44) Promise.all([p1, p2, p3]).then(value =\u0026gt; { \tconsole.log(value); // [42,43,44] }) // 拒绝 let p1 = Promise.resolve(42) let p2 = Promise.reject(43) let p3 = Promise.resolve(44)  Promise.all([p1, p2, p3]).then(value =\u0026gt; { \tconsole.log(value); }).catch(err =\u0026gt; { \tconsole.log(err); // 43 }) Promise.race #  接受一个参数，并返回一个promise，该参数是一个含有多个受监视的Promise对象（比如数组），只要有一个Promise被解决后返回的Promise就会被解决，无需等到所有的Promise都完成，只要当可迭代对象中有的Promise被完成返回的Promise才会被完成。\n 实际上Promise.race会进行竞选，如果先解决的是已完成，则返回已完成的Promise；如果先解决的是已拒绝，则返回已拒绝的Promise   let p1 = Promise.resolve(42); let p2 = Promise.reject(43) let p3 = Promise.resolve(44)  Promise.race([p1, p2, p3]).then(value =\u0026gt; { \tconsole.log(value); // 42 }).catch(err =\u0026gt; { \tconsole.log(err); }) // 竞选 let p1 = new Promise((resolve, reject) =\u0026gt; { \tsetTimeout(() =\u0026gt; { \tresolve(42) \t},10) }); let p2 = Promise.reject(43) let p3 = Promise.resolve(44)  Promise.race([p1, p2, p3]).then(value =\u0026gt; { \tconsole.log(value); }).catch(err =\u0026gt; { \tconsole.log(err); // 43 }) Promise的继承 #  由于静态方法绘本继承，因此派生类也会拥有resolve、reject、all、race等方法\nclass MyPromise extends Promise{ \tsuccess (resolve, reject) { \treturn this.then(resolve, reject) \t} \tfailure (reject) { \treturn this.catch(reject) \t} } let pro = new MyPromise(function (resolve, reject) { \tresolve(42) }) pro.success(value =\u0026gt; { \tconsole.log(value);\t// 42 }).failure(err =\u0026gt; { \tconsole.log(err); }) "},{"id":10,"href":"/draft/katex/","title":"关于latex格式的前端渲染","section":"Drafts","content":"最近由于工作原因开始接触laex格式的渲染，主要是相关复杂公式的渲染数学公式、物理公式等；渲染方式主要有服务端渲染展示图片、前端渲染html形式展示公式；这里只说说前端渲染前的方式。以前也没有接触过类似的东西通过调研多个库，主要有MathJax、katex的渲染方式；这里主要讲katex的渲染方式。\n什么是latex？ #  摘自维基百科\nLaTeX， 是一种基于TEX的排版系统，由美国电脑学家莱斯利·兰伯特在20世纪80年代初期开发，利用这种格式，即使用户没有排版和程序设计的知识也可以充分发挥由TEX所提供的强大功能，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。 简单的说 LaTeX 基于 TeX，主要目的是为了方便排版。在学术界的论文，尤其是数学、计算机等学科论文都是由 LaTeX 编写, 因为用它写数学公式非常漂亮。 MathJax #  MathJax的官网地址，中文文档地址点这里\n引入MathJax #  官网cdn\n\u0026lt;script type=\"text/javascript\" src=\"http://cdn.mathjax.org/mathjax/1.1-latest/MathJax.js\"\u0026gt;\u0026lt;/script\u0026gt; 因为MathJax是自动识别dom的，引入成功之后如果包含latex格式的标签会自动转换比如： \u0026lt;p\u0026gt;∵集合$$A=\\left\\{ x|x\u0026amp;lt;{}1 \\right.$$或$$\\left. x\u0026amp;gt;3 \\right\\}$$，$$B=\\left\\{ x|2x-4\u0026amp;gt;0 \\right\\}=\\left\\{ x|x\u0026amp;gt;2 \\right\\}$$，\u0026lt;/p\u0026gt; 与此同时官方也给我们提供了配置函数\n\u0026lt;!-- type必须是text/x-mathjax-config --\u0026gt; \u0026lt;script type=\u0026#34;text/x-mathjax-config\u0026#34;\u0026gt; window.MathJax.Hub.Config({  showProcessingMessages: false, //关闭js加载过程信息  messageStyle: \u0026#34;none\u0026#34;, //不显示信息  jax: [\u0026#34;input/TeX\u0026#34;, \u0026#34;output/HTML-CSS\u0026#34;],  tex2jax: {  \u0026lt;!-- 由于MathJax 没有css 所以有些时候会出现样式不对，注意设置好 inlineMath、displayMath 属性--\u0026gt;  inlineMath: [[\u0026#34;$\u0026#34;, \u0026#34;$\u0026#34;], [\u0026#34;\\\\(\u0026#34;, \u0026#34;\\\\)\u0026#34;]], //行内公式选择符  displayMath: [[\u0026#34;$$\u0026#34;, \u0026#34;$$\u0026#34;], [\u0026#34;\\\\[\u0026#34;, \u0026#34;\\\\]\u0026#34;]], //段内公式选择符  skipTags: [\u0026#34;script\u0026#34;, \u0026#34;noscript\u0026#34;, \u0026#34;style\u0026#34;, \u0026#34;textarea\u0026#34;, \u0026#34;pre\u0026#34;, \u0026#34;code\u0026#34;, \u0026#34;a\u0026#34;], //避开某些标签  ignoreClass: \u0026#34;class1|class2\u0026#34; //避开 特定 标签  },  \u0026#34;HTML-CSS\u0026#34;: {  availableFonts: [\u0026#34;STIX\u0026#34;, \u0026#34;TeX\u0026#34;], //可选字体  showMathMenu: false //关闭右击菜单显示  }  }); \u0026lt;/script\u0026gt; 默认情况是对我们整个DOM进行处理的，可以传递参数来指定渲染范围(可以极大的提高渲染性能)\nwindow.MathJax.Hub.Queue([\u0026#34;Typeset\u0026#34;, MathJax.Hub, document.getElementById(\u0026#39;app\u0026#39;)]); MathJax给我们提供了部分右键菜单通过设置可以控制显示\n\u0026#34;HTML-CSS\u0026#34;: {  showMathMenu: false }  默认的公式会有蓝框，我们可以通过设置样式覆盖修改样式\n蓝色的边框 .MathJax{outline:0;} 如果要改变字体大小 .MathJax span{font-size:15px;} 公式太长的时候会溢出 .MathJax_Display{overflow-x:auto;overflow-y:hidden;} 去掉加载信息，MathJax加载会在网页左下角看到加载情况，可以直接在MathJax.Hub.Config()里配置去掉\nMathJax.Hub.Config({  showProcessingMessages: false,  messageStyle: \u0026#34;none\u0026#34; }); 更多 #  更多关于tex2jax的配置点击\n katex 最快的公式渲染 #  katex是可汗学院推出的一种解析latex的库，具有简单的api、无依赖、高效、快速、服务器端渲染的js解析库； 特点：\n 简单的API：不依赖其它 javascript库； 快速：KaTeX 是将其数学同步且不需要回流页； 输出质量：KaTeX 的布局是基于 Donald Knuth 的 Tex ，数学排版的黄金标准； 服务器的渲染：无论浏览器或环境如何，KaTeX 输出保持一致，因此可使用 Node.js 预渲染表达式，并将其作为纯 HTML 发送。  该库只支持纯粹的latex格式的渲染，如果包含html实体、或者标签将渲染失败 官网在此\n引入katex #  1.通过cdn引入\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.css\u0026#34; integrity=\u0026#34;sha384-dbVIfZGuN1Yq7/1Ocstc1lUEm+AT+/rCkibIcC/OmWo5f0EA48Vf8CytHzGrSwbQ\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.js\u0026#34; integrity=\u0026#34;sha384-2BKqo+exmr9su6dir+qCw08N2ZKRucY4PrGQPPWU1A7FtlCGjmEGFqXCv5nyM5Ij\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; // 以下是一个自动渲染的插件 \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/contrib/auto-render.min.js\u0026#34; integrity=\u0026#34;sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 该defer属性 表示在页面加载之前不需要执行脚本，从而加快了页面呈现速度; 和onload属性调用 renderMathInElement一次自动渲染脚本负荷。  document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() {  renderMathInElement(document.body, {  // ...options...  });  }); \u0026lt;/script\u0026gt;   integrity:是允许浏览器检查其获得的资源（例如从 CDN 获得的）是否被篡改的一项安全特性。具体信息请参考web 安全|MDN\n  defer：这个布尔属性被设定用来通知浏览器该脚本将在文档完成解析后，触发 DOMContentLoaded 事件前执行。如果缺少 src 属性（即内嵌脚本），该属性不应被使用，因为这种情况下它不起作用。对动态嵌入的脚本使用 async=false 来达到类似的效果。script|MDN\n  crossorigin:那些没有通过标准CORS检查的正常script 元素传递最少的信息到 {domxref(\u0026lsquo;GlobalEventHandlers.onerror\u0026rsquo;, \u0026lsquo;window.onerror\u0026rsquo;)}。可以使用本属性来使那些将静态资源放在另外一个域名的站点打印错误信息。script|MDN\n  当然还有AMD、ECMAScript module的引入具体请移步官网 如果使用了前端打包工具也可以使用npm引入\nnpm install katex / yarn add katex // 这样全局就会 有katex import katex from \u0026#39;katex\u0026#39;; // 别忘了引入css import \u0026#39;katex/dist/katex.min.css\u0026#39; API #  katex.render #  该方法会将公式渲染的结果返回到elemnet里\n// 官方实例 katex.render(\u0026#34;c = \\\\pm\\\\sqrt{a^2 + b^2}\u0026#34;, element, {  throwOnError: false }); // 如果需要转义那么可以这样 katex.render(String.raw`c = \\pm\\sqrt{a^2 + b^2}`, element, {  throwOnError: false }); 请注意本地复制代码测试的时候要去掉转义字符,不然会出现错误 katex.renderToString #  该渲染方法会将生成的dom结构输出到html\nvar html = katex.renderToString(\u0026#34;c = \\\\pm\\\\sqrt{a^2 + b^2}\u0026#34;, {  throwOnError: false }); renderMathInElement #  插件的使用，引入插件的js后，会获得一个全局的函数renderMathInElement\ndocument.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() {  renderMathInElement(document.body, {  // ...options...  });  }); 该函数提供两个参数，第一个提供dom节点就是说会渲染该dom节点下的公式元素（尽可能的精确会提高性能），第二个参数是分隔符配置文件，将分隔符以内的字符串会进行katex渲染，配置如下\n// display设置为true会被渲染成块元素，false是行内元素  {  delimiters: [  {left: \u0026#34;$$\u0026#34;, right: \u0026#34;$$\u0026#34;, display: false},  {left: \u0026#34;\\[\u0026#34;, right: \u0026#34;\\]\u0026#34;, display: true},  {left: \u0026#34;$\u0026#34;, right: \u0026#34;$\u0026#34;, display: false},  {left: \u0026#34;\\(\u0026#34;, right: \u0026#34;\\)\u0026#34;, display: false }  ] } 这些就是katex的基本api，具体的使用请参考官网\n总结 #  不管是render、还是renderToString都只支持纯公式的渲染一旦包含标签或者其他不是公式的元素字符串那么就会渲染失败，而renderMathInElement插件的渲染虽然良好的支持各种标签混合的字符串处理，但是又不能支持字符串的输出。我简单的修改了下renderMathInElement的源码使之能输出DOM字符串可以直接渲染，如果你使用vue那么会很方便的使用v-html渲染，这样就解决了后端请求的时候的少量渲染，并且不会引起大量的重绘、回流。\n源码点这儿 --  npm 集成v-katex "},{"id":11,"href":"/draft/high-javascript/process-control/","title":"算法和流程控制","section":"高性能JavaScript","content":"循环类型 #  // for循环 for(var i = 0; i\u0026lt;items.length; i++){} // while循环 var i= 0; while(i\u0026lt;items.length){} // do-while var j = 10 ; do{}while(j\u0026lt;items.length) // for-in for(var key in object){  // 函数体 }  // 每次循环所经历的步骤 1. 在控制条件中查找一次属性(items.length) 2. 在控制条件中执行一次数值比较(i\u0026lt;items.length) 3. 一次比较操作,查看控制条件的计算是否为true(i\u0026lt;items.length === true) 4. 一次自增(i++) 5. 一次数值查找(items[i]) 6. 一次函数体执行 减少迭代的工作量 #   for-in循环每次迭代都需要搜索实例和原型,因此每次迭代会带来更多的开销，对比同等次数和\u0008环境for-in循环最终只有\u0008其他循环类型的1/7 2.由于操作局部变量和字面量要比\u0008查找对象成员和数组项的查找要快，对于数组或者对象来说length一般是没有改变的所有通过缓存局部变量可以提高性能   // 大多数浏览器可以节约25%的时间，IE甚至可以节约50%  for(var i = 0;len = item.length i\u0026lt;len; i++){} 3.通过\u0008改变数组顺序来提高循环性能:通常数组顺序与要执行的任务无关，倒序循环是编程语言中的一种通用性能优化方案，\n // for循环  for(var i = items.length; i--){}  // while循环  var i= item.length; while(i--){}  // do-while  var j = items.length-1 ; do{}while(j--)  //以上控制条件只是简单的与0比较，控制条件从两次比较减少到一次，提高循环性能，\u0008一般可以提高50%-60%  优化后每次循环所经历的步骤  1. 一次比较操作，查看控制条件的计算是否为true(i === true)  2. 一次自减(i--)  3. 一次数值查找 (items[i])  4. 一次函数体执行  当复杂度为O(n)时，减少每次迭代的步骤次数是最有效的，当复杂度为大于O(n)时，建议着重减少迭代次数 减少迭代次数 #  duff‘s Device(\u0008达夫设备)\u0008是一种循环体展开技术，它使得一次迭代中实际执行了多次迭代。当循环次数超过1000的时候duff‘s Device的执行效率将明显提升，在500000次迭代中，其运行时间比 常规少70%\n条件语句 #   关于使用switch还是if-else，通常数量比较越大更倾向于使用switch而不是if-else。\u0008事实证明大多数情况下switch比if-else更快，当然是在一定数量的情况下。原因是当条件增加时if-else性能负担增加的程度比switch要多(大多数的语言对switch语句都采用了branch table(分支表)索引来进行优化，并且在switch语句比较值的时候使用全等===操作符，不会发生类型转换的消耗) 通过构建数组作为查找表来替代条件语句，随着数量的增大也几乎不会产生额外的性能开销  递归 #  潜在问题是终止条件不明确或者说缺少终止条件会导致函数长时间运行，使用户界面处于假死状态。并且还有可能遇到浏览器的调用栈大小限制\n 任何递归都能用迭代实现 使用Memoization技术优化递归的重复计算  是一种将函数返回值缓存起来的方法，Memoization 原理非常简单，就是把函数的每次执行结果都放入一个键值对(数组也可以，视情况而定)中，在接下来的执行中，在键值对中查找是否已经有相应执行过的值，如果有，直接返回该值，没有才 真正执行函数体的求值部分。很明显，找值，尤其是在键值对中找值，比执行函数快多了。 Fibonacci例子 //递归调用 function fibonacci(n){ if(n==0||n==1){  return n;  }  return fibonacci(n-1) + fibonacci(n-1); } //缓存优化 var fibonacci = function(){  if(!memfactorial.cache){  memfactorial.cache = {  0:1,  1:1  }  }   if(memfactorial.cache.hasOwnPrototype(n)){  memfactorial.cache[n] = n * fibonacci(n-1)  }   return memfactorial.cache[n] };     "},{"id":12,"href":"/draft/ssh/","title":"github 免登录","section":"Drafts","content":"github支持ssh公钥的登录,在github同步公钥后不再需要输入账号密码，就可以实现git的相关操作\n客服端生成公钥 #  \u0008在客服端执行 ssh-kengen -t rsa -C “email@address” 一直回车（期间可以输入验证串，那么以后也会输入该串配对验证，一般不需要）即可在生成公钥和私钥\ncd ~/.ssh 可以看到id_rsa.pub就是我们所生成的公钥\n# 推送到远程服务器 ssh-copy-id user@server 配置github #  添加公钥到github账号 使用网页登陆github，在settings–\u0026gt;ssh keys–\u0026gt;add key 把id_rsa.pub 里面的公钥复制到这类，title随便取一个名字就可以了\n测试账号 #  ssh git@github.com  Hi xxxx! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 表示连接成功 克隆项目 #  git clone git@github.com:username/projectname.git\n注意事项切记一定要采用git@github.com的ssh模式不然会报错\ngit设置全局用户名 #  git config \u0026ndash;global user.name \u0026ldquo;username\u0026rdquo;\ngit config \u0026ndash;global user.email \u0026ldquo;address@mail\u0026rdquo;\n"},{"id":13,"href":"/draft/high-javascript/data/","title":"数据存取","section":"高性能JavaScript","content":"作用域链 #  每一个javascript函数都可以表示为一个对象，更确切的说，是Function对象的一个实例，拥有可以编程访问的属性和一系列不能访问的内部属性，其中一个是[[Scope]]。内部属性[[scope]]包含了\u0008一个函数被创建作用域中对象的集合，那么这个集合被称为作用域链，它决定了那些能被函数访问。\n当函数被执行时会创建一个执行环境，每个执行环境都有自己的作用域，用于解析标识符，在函数的执行中每遇到\u0008一个变量都会经历一次标识符解析，会持续的在作用域链中去搜索匹配这个对象，正是这个过程影响了性能，\u0008正是由于标识符的解析过程，所以出现同名的变量那么第二个会覆盖第一个变量。\n局部变量 #  由于全局变量会在最远处，所以最好使用局部变量会更快。 由于很多全局变量比如document等，通过在函数局部声明变量来承载，会提高性能\nfunction test(){  links = document.getElementByTagName(\u0026#39;a\u0026#39;)  document.getElementById(\u0026#39;click\u0026#39;).onClick = function(){   }  // 以上的案例会搜索全局变量document两次  var dc = document  links = dc.getElementByTagName(\u0026#39;a\u0026#39;)  dc.getElementById(\u0026#39;click\u0026#39;).onClick = function(){   }  // 以上案例智慧搜索一次全局变量document，解析\u0008标识符的路径会更短 } 闭包 #  由于在闭包存在的情况下，执行环境无法被销毁，也就是说会消耗更多的内存。在使用闭包的情况下会创建一个执行环境与属性[[scope]]中所引用的相同作用域对象一起被初始化；在闭包中用到的标识符，位于作用域链的第一个作用域之后，在频繁的跨作用域访问标识符，会带来性能损耗\n对象成员 #  javascript是基于原型。原型是对象的基础；对象通过内部属性_proto_绑定其成员变量。当函数或者对象读取或者执行的时候，会在当前实例搜索变量，没有则继续搜索原型对象，可以通过hasOwnProperty、in操作符来判断当前实例是否具有该属性或者方法。正是这个逐级搜索的过程严重的拖慢了访问成员变量的时间\n1. 嵌套成员:对象中包含其他对象，例如window.location.href每次遇到点操作符，嵌套成员会导致javascript引擎搜索所有对象成员，嵌套的越深读取速度就越慢，执行location.href\u0008总会比window.location.href要快。（在大部分浏览器中点操作和括号表示法没有明显的区别，只有Safari中点操作始终比括号表示法更快）\n2. 缓存对象成员:在同一函数中没必要多次读取同一个对象成员。通常来说在函数中需要多次读取一个对象属性，最佳做法是局部变量缓存，降低多次查找带来的开销，特别是在处理嵌套成员的时候。不要再同一函数下多次查找一个对象，除非这个对象值变化了\n小结 #   访问字面量和局部变量\u0008速度最快，访问数组和对象成员相对会慢 局部变量处于顶端起始位置会比跨作用域访问更快；而全局变量处于作用域末端，访问速度最慢 避免使用with，它会改变\u0008执行环境的作用域链；try-catch中的catch也会改变执行环境作用域链，因此需要小心使用 嵌套成员明显影响性能，尽可能少用 通常来说使用缓存变量到函数的局部环境，会改善javascript性能  "},{"id":14,"href":"/draft/high-javascript/load-and-execute/","title":"加载与执行","section":"高性能JavaScript","content":"概述 #  多数浏览器使用单一进程来处理用户界面（UI）刷新和javascript脚本的执行，所以同一时间只能做一件事，js执行时间越久，浏览器等待响应时间就越长。script标签的每次出现，页面会等待脚本的解析和执行；不管是和内联好还是外链，页面的下载和渲染都必须等待脚本 的执行。这个过程中的页面交互式完全阻塞的。\n脚本位置\u0008 script标签位置 #   浏览器在解析到body标签之前不会渲染任何页面，如果把脚本放在顶部，通常表现为页面空白 每个脚本必须等到前一个脚本下载完成、\u0008执行完成才会开始下载和执行；瀑布图中显示的下载间隔刚好是前一个脚本的\u001c执行时间   结论：推荐将所有的\u0026lt;script\u0026gt;标签尽可能的放到标签的底部，以尽量减少对整个页面下载的影响  组织脚本 #   由于每个\u0026lt;script\u0026gt;标签的初始下载都会阻塞页面的渲染，减少页面包含的\u0026lt;script\u0026gt;标签有利于改善性能； 考虑到http\u0008的网络消耗，下载单个100k会比4个25k要快同时浏览器解析html页面每遇到一个脚本标签，都会因为执行脚本导致一定的延迟，\u0008因此脚本的数量也需要限制。 （Steve Souders）把内联的脚本放在\u0026lt;link\u0026gt;标签之后,也会导致页面阻塞去等待样式表的下载。（目的：\u0008确保内嵌脚本在执行时能或得最精准的样式信息），建议永远不需要把内嵌脚本放在\u0026lt;link\u0026gt;标签之后 脚本合并：通常将\u0008多个文件合并成一个文件下载，比如Yahoo的合并处理器  1.静态资源打包：服务器将多个文件合并成一个文件 \u0026lt;script src=\u0026#34;http://a.tbcdn.cn/??s/kissy/1.1.6/kissy-min.js,p/global/1.0/global-min.js,p/et/et.js?t=2011092320110301.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 针对上面这个案例，那么服务器端你在这个请求的接口里，根据js参数的值，把a.js到e.js的内容读取出来，再合并成一个文件（一般同时还会压缩，比如去空格，比如缩短变量名等），输出到客户端。如果服务器端再加上缓存，那可能连合并都不需要了。这样页面加载速度会快非常多。比较常用的js打包工具有google的google closure，css用yui compressor。 无阻塞脚本 #  核心在于页面加载完成后才加载javascript代码，意味着window对象的load事件触发后在加载脚本\n 并行下载\u0026lt;script\u0026gt;标签在下载外部资源不会阻塞其他的\u0026lt;script\u0026gt;标签。虽然脚本的\u0008下载过程不会相互影响，但是页面仍然会等待所有的脚本下载并执行才能继续。 扩展属性（共同点都是并行下载）  defer:（html4）指明本元素所包含的脚本不会修改dom\u0008，代码可以安全的延迟执行（只有IE支持），该属性会在并行下载后等待页面完成后执行；任何带有defer属性的javascript文件下载时，它不会阻塞浏览器的其他进程，因此这类文件可以与页面其他资源并行下载(仅当src属性声明时才生效) sync:（html5）加载完成后自动执行     动态脚本元素 #  动态添加脚本元素到页面，使用动态脚本下载，返回的代码通常会立即执行\nfunction loadScript(url,callback){  var script = document.createElement(\u0026#39;script\u0026#39;)  script.type = \u0026#39;text/javascript\u0026#39;  if(script.readyState){  // 兼容IE  script.onreadystatechange = function(){  if(script.readyState==\u0026#39;loaded\u0026#39;||script.readyState==\u0026#39;complete\u0026#39;){  script.onreadystatechange = null  callback()  }  }  }else{  script.onload = function(){  callback()  }  }   script.url = url  document.getElementsByTagName(\u0026#39;head\u0026#39;)[0].appendChild(script) } // 调用 将代码放到body闭合标签前；1）确保js执行不会阻塞页面；2）避免监听其他事件比如window.onload loadScript(\u0026#39;test.js\u0026#39;,function(){  // do something }) 可以使用YUI3、LazyLoad、LABjs来完成类似的工作 小结 #   将所有脚本放在页面的底部加载执行 合并脚本 无阻塞下载  defer属性、sync属性 动态脚本元素 xhr下载脚本注入    "},{"id":15,"href":"/docs/notes/git/","title":"Git","section":"一些杂记","content":" 本地与远程的分支列表不一致(在gitlab管理界面删除分支之后) git remote update origin --prune  error: failed to push some refs to git pull --rebase origin master git push -u origin master  拉取git子模块 git submodule update --init --force   "}]