[{"id":0,"href":"/docs/notes/tools/jb/","title":"2022年JB开发工具","section":"Tools","content":" 且用且珍惜，支持正版 # JB的激活方式有账号激活、激活码、服务器三种\n服务器激活 # 打开网站 # https://search.censys.io/\n搜索 # 1services.http.response.headers.location: account.jetbrains.com/fls-auth 查找 # 点击搜索，在返回的结果随便找一个点进去，查找到HTTP/302\n激活 # 复制网址到jb，选择许可证服务器/License server，粘贴刚刚复制的网址，激活。 重试 # 如果失败，换一个就试一试就好 脚本激活 # 地址 # 获取相关工具的地址 https://jetbra.in/s 操作 # 将下载的zip解压到指定位置，不再移动 cd scripts 执行install脚本 重启IDE 再去上面的网站获取对应的code 完成激活 "},{"id":1,"href":"/docs/notes/fe/webpack/","title":"Webpack","section":"前端工具","content":" extensions # 补全规则 # js支持不写后缀的引入方式,在引入的过程中会尝试补全扩展名或者路径\n文件扩展名 # 如果加载的路径不携带文件扩展名，会尝试补全.ts、.tsx等文件扩展，在webpack中可以配置可能的文件扩展名，如下：\n1resolve: { 2 extensions: [\u0026#39;.ts\u0026#39;, \u0026#39;.tsx\u0026#39;, \u0026#39;.js\u0026#39;] 3 ... 4} 如下，会尝试加载ts、tsx、js\n1import A from \u0026#39;a\u0026#39; 补全路径 # 在尝试文件扩展名之后，依然没有找到文件，但是发现该路径是一个目录，则会在改路径的目录下寻找package.json,如果存在则加载package.json中的main字段对应的文件，如果不存在则会尝试寻找目录下的index文件\n妙用 # 在项目的开发过程中通常需要根据不同的参数加载不同的页面文件，通过webpack的extensions可以剥离业务代码耦合的情况下，分别加载。\n实例 # 入口文件app.js 1import Home from \u0026#34;./Home\u0026#34; 2function App() { 3return ( 4 \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; 5 \u0026lt;Home/\u0026gt; 6 \u0026lt;/div\u0026gt; 7); 8} 9export default App 需要加载的文件 Home/index.js 1function Home() { 2return \u0026lt;h1\u0026gt;TT Home\u0026lt;/h1\u0026gt; 3} 4export default Home Home/index.tt.js 1function Home() { 2return \u0026lt;h1\u0026gt;TT Home\u0026lt;/h1\u0026gt; 3} 4export default Home 在webpack中配置 process.env.TYPE 可以通过cross-env 注入 1resolve{ 2 extensions:[ 3 // 这里需要注意优先级需要写在前面 4 `.${process.env.TYPE}.js`, 5 \u0026#39;.js\u0026#39; 6 ] 7} 现在你可以在通过不同的type参数来控制程序打包时候加载的页面，并且对业务代码是无入侵的 "},{"id":2,"href":"/docs/notes/tools/docker/","title":"Docker","section":"Tools","content":" 安装 # 腾讯云镜像安装（debian） # 1sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common 2 3curl -fsSL https://mirrors.cloud.tencent.com/docker-ce/linux/debian/gpg | sudo apt-key add - 4 5sudo add-apt-repository \u0026#34;deb [arch=amd64] https://mirrors.cloud.tencent.com/docker-ce/linux/debian $(lsb_release -cs) stable\u0026#34; 6 7sudo apt-get update 8 9sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin 镜像安装加速 # 打开 /etc/docker/daemon.json 配置文件。 1vim /etc/docker/daemon.json 添加 1{ 2 \u0026#34;registry-mirrors\u0026#34;: [ 3 \u0026#34;https://mirror.ccs.tencentyun.com\u0026#34; 4 ] 5} 重启docker 1sudo systemctl restart docker "},{"id":3,"href":"/docs/notes/tools/terminal/","title":"Terminal","section":"Tools","content":" 终端的相关快捷键 # control + a 移动到行首 control + e 移动到行尾巴 常见命令 # mkdir # 创建新的文件夹\n1# 创建一个权限为777的文件夹 2mkdir -pv -m 777 /user/test p: 确保目录名称存在，不存在的就建一个（递归创建） m: 设置权限 v: 显示创建过程信息 "},{"id":4,"href":"/docs/notes/typescript/extends/","title":"Extends","section":"typescript学习笔记","content":" extends # 官方文档\n接口继承和类型判断\n继承扩展 # 1interface Person{ 2 name: string 3} 4 5interface Sudent extends Person{ 6 age: number 7} 8// Student =\u0026gt; {name: string ge:number} 泛型约束 # 在使用泛型的时候，可以通过extends来对类型参数的限制； 以下的案例可以限制obj传入的对象必须包含name字段 1function getName\u0026lt;T extends {name:string}, K extends keyof T\u0026gt;(obj:T, key:K){ 2 return obj[key] 3} 条件判断 # 当extends和type一起使用的时候，会作为条件判断 如果extends前面的类型能够赋值给extends后面的类型，那么表达式判断为真，否则为假。 extends前面的类型一定包含后一个类型 1interface Point{ 2 x: number 3 y: number 4} 5interface PointY{ 6 y:number 7} 8type P = Point extends PointY ? \u0026#39;string\u0026#39; : \u0026#39;number\u0026#39; 9// P =\u0026gt; string 10// 满足Point 一定能满足 PointY 分配条件类型 # 1type P\u0026lt;T\u0026gt; = T extends \u0026#39;x\u0026#39; ? string : number; 2type A3 = P\u0026lt;\u0026#39;x\u0026#39; | \u0026#39;y\u0026#39;\u0026gt; // A3的类型是 string | number 这里实际上类似于分配律 P\u0026lt;'x' | 'y'\u0026gt; =\u0026gt; P\u0026lt;'x'\u0026gt; | P\u0026lt;'y'\u0026gt;\n特殊never # never是所有类型的子类型\n1type A1 = never extends \u0026#39;x\u0026#39; ? string : number; // string 2type P\u0026lt;T\u0026gt; = T extends \u0026#39;x\u0026#39; ? string : number; 3type A2 = P\u0026lt;never\u0026gt; // never 阻止分配 # 将泛型使用[]括起来，防止分配\n1 type P\u0026lt;T\u0026gt; = [T] extends [\u0026#39;x\u0026#39;] ? string : number; 2 type A1 = P\u0026lt;\u0026#39;x\u0026#39; | \u0026#39;y\u0026#39;\u0026gt; // number 3 type A2 = P\u0026lt;never\u0026gt; // string "},{"id":5,"href":"/docs/notes/typescript/record/","title":"Record","section":"typescript学习笔记","content":" Record\u0026lt;Keys, Type\u0026gt; # 官方文档\n定义一个对象的key和value类型\n构造一个对象类型，其属性键为Keys，其属性值为Type。 此实用程序可用于将一种类型的属性映射到另一种类。\n接口 # 1// 定义 2// type Record\u0026lt;K extends keyof any, T\u0026gt; = { 3// [P in K]: T; 4// }; 5interface Person { 6 age: number 7 name: string 8} 9type School = \u0026#39;student\u0026#39; | \u0026#39;teacher\u0026#39; 10const school: Record\u0026lt;School, Person\u0026gt; = { 11 student: { 12 name: \u0026#39;tom\u0026#39;, 13 age: 12 14 }, 15 teacher:{ 16 name: \u0026#39;sam\u0026#39;, 17 age:20 18 } 19} 基础类型 # 1type Num = \u0026#34;one\u0026#34; | \u0026#34;two\u0026#34; 2 3const num: Record\u0026lt;Num, number\u0026gt; = { 4 one:1, 5 two:2 6} "},{"id":6,"href":"/docs/notes/typescript/keyof/","title":"Keyof","section":"typescript学习笔记","content":" keyof # 该操作符用于获取某种类型的所有键,其返回的类型是联合类型\n获取类型 # 1interface Ponit{ 2 x:number 3 y:number 4} 5 6type P = keyof Ponit // \u0026#39;x\u0026#39; | \u0026#39;y\u0026#39; 索引签名 # 1type Arrayish = { 2 [n:number]: unknown 3} 4type A = keyof Arrayish // number 常用场景 # 定义一个函数，通过key来获取对象的值，通常我们并不知道对象包含的key集合\n1function getObject\u0026lt;T extends object, K extends keyof T\u0026gt;(obj:T, key:K){ 2 return obj[key] 3} 4const point = { 5 x: 12, 6 y:13 7} 8getObject(point,\u0026#39;x\u0026#39;) 9getObject(point,\u0026#39;z\u0026#39;) //类型“\u0026#34;z\u0026#34;”的参数不能赋给类型“\u0026#34;x\u0026#34; | \u0026#34;y\u0026#34;”的参数。 "},{"id":7,"href":"/readbook/0501/","title":"浮生六记","section":"读书小计","content":"《浮生六记》- 沈复\n无人与我立黄昏，无人问我粥可温。\n无人与我捻熄灯，无人共我书半生。\n无人陪我夜已深，无人与我把酒分。\n无人拭我相思泪，无人梦我与前尘。\n无人陪我顾星辰，无人醒我茶已冷。\n无人听我述衷肠，无人解我心头梦。\n无人拘我言中泪，无人愁我独行路。\n回首向来萧瑟处，无人等在灯火阑珊处。\n"},{"id":8,"href":"/docs/notes/tools/git/","title":"git命令","section":"Tools","content":" 常见配置 # 配置全局 # git config \u0026ndash;global user.name \u0026lsquo;global\u0026rsquo; git config \u0026ndash;global user.email \u0026lsquo; global@global.com\u0026rsquo; 查看配置 # git config user.name # global git config user.email # global@global.com 分离工作和个人 # 公司项目都在 work 目录下，给这个目录搞个配置，只要这个目录下的就是 workname 而不是 global 首先创建一个文件 1sudo vim ~/.gitconfig-work # 这个文件和 .gitconfig 同一目录好管理 内容 1# ～/.gitconfig-work 2 3[user] 4 name = workname 5 email = workname@company.com 修改.gitconfig 1# ～/.gitconfig 2 3[http] 4 5... 6 7[includeIf \u0026#34;gitdir:~/work/\u0026#34;] 8 path = .gitconfig-work 常见问题 # 本地与远程的分支列表不一致(在gitlab管理界面删除分支之后) 1git remote update origin --prune error: failed to push some refs to 1git pull --rebase origin master 2git push -u origin master 拉取git子模块 1git submodule update --init --force "},{"id":9,"href":"/docs/notes/tools/vim/","title":"vim常用命令","section":"Tools","content":"主要记录 vim 使用过程中的快捷键\n输入模式 # i 切换输入模式 a 光标后插入 A 光标行尾插入 i 光标前插入 I 光标行首插入 o 打开向下打开新行 O 打开向上打开新行 退出模式 # esc 保存 # w wq wq！ q! wq! (root 文件所有者可以操作) 命令模式 # 快捷键 # h 向左 j 向下 k 向上 l 向右 gg 文件头 G 文件尾 快速跳转 # ^ 行首 $ 行尾 :n 跳到指定 n 行 x 删除一个字母 xn 删除 P 指定 n 个字母 dd 删除单行 ndd 删除 n 行 剪切/粘贴/撤销 # p 粘贴光标上面 P 粘贴光标下面 :n1,n2d 剪切多行 n 行号 dG 先执行 gg 文件头 从光标删除到文件尾 u 撤销 一直到文件打开状态 control+r 反撤销 替换 # r 替换单个 R 替换模式 查找 # ? 光标向上 / 光标向下 n 下一个 N 上一个 其他 # r 导入其他文件内容 :r abc.txt ! 命令 在 vim 执行系统命令 r !命令 导入命令的结果 map 自定义快捷键 o 上下打开多个文档 control+w 上下箭头 切换文件 O 左右打开多个文档 control+w 左右箭头 切换文件 "}]