<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>javascript on zggz Book</title>
    <link>https://zggz.github.io/draft/javascript/</link>
    <description>Recent content in javascript on zggz Book</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://zggz.github.io/draft/javascript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>代理和反射</title>
      <link>https://zggz.github.io/draft/javascript/reflect-proxy/</link>
      <pubDate>Sat, 09 May 2020 15:12:09 +0000</pubDate>
      
      <guid>https://zggz.github.io/draft/javascript/reflect-proxy/</guid>
      <description>代理(Proxy)是一种可以拦截并改变底层JavaScript引擎的操作包装器，在新语言中通过它暴露内部运作对象，从而让开发者可以创建内建对象
代理和反射 #  代理 #  调用new Proxy()可以创建代替其他目标对象的代理，虚拟化了目标，使其二者看起来功能一致，代理可以拦截JavaScript引擎内部目标的底层对象操作，这些底层操作被拦截后会触发响应特定操作的陷阱函数。
用Proxy构造函数创建代理需要两个参数： 目标(target)和处理程序(handler)，处理程序定义一个或者多个陷阱的对象，除去专门特定的操作定义外，其余操作均使用默认特性
let t = {} let p = new Proxy(t, {}) p.name = &amp;#39;hello proxy&amp;#39; console.log(p); // { name: &amp;#39;hello proxy&amp;#39; } console.log(t); // { name: &amp;#39;hello proxy&amp;#39; } 反射 #  反射API以Reflect对象的形式出现，对象中的方法默认特性相应的底层操作一致。而每一个代理陷阱会对应一个命名和参数都相同的Reflect方法(其实就是每个代理陷阱都会对应一个Reflect api接口供覆写JavaScript底层操作)
代理陷阱特性
   代理陷阱 覆写的特性 默认特性     get 读写一个属性值 Reflect.get()   set 写入一个属性 Reflect.set()   has in操作 Reflect.has()   deleteProperty delete操作符 Reflect.</description>
    </item>
    
    <item>
      <title>promise</title>
      <link>https://zggz.github.io/draft/javascript/promise/</link>
      <pubDate>Wed, 06 May 2020 21:40:35 +0000</pubDate>
      
      <guid>https://zggz.github.io/draft/javascript/promise/</guid>
      <description>Javascript引擎基于单线程事件循环，同一时间只运行一个代码块运行；反之多线程是运行多个代码块同时执行。
所以JavaScript需要跟踪即将运行的代码，将这些代码放在一个任务队列中，当代码准备执行的时候都会添加到任务队列中，当一段代码执行结束，事件循环会执行队列下一个任务。队列中的任务会从第一个一直执行到最后一个
  事件模型：用户点击键盘或者触发类似onclick事件，会想任务队列增加一个任务来响应用户的操作，直到事件触发才执行事件处理程序，这是JavaScript中最基础的异步编程
  回调模式：Nodejs通过普及回调函数拉改进异步编程模型，异步代码会在未来某个时间执行，回调模式中被调用的函数式作为蚕食传入的。
  Promise基础 #  promise相当于一个异步操作结果的占位符，它不会去订阅一个事件，也不会传递一个回调函数给目标，而是返回一个Promise。
// readFili承诺将来某个时刻完成 let promiss = readFile(&amp;#39;example.txt&amp;#39;) 创建Promise #  let fs = require(&amp;#39;fs&amp;#39;) function readFile () { 	return new Promise((resolve, reject) =&amp;gt; { 	fs.readFile(&amp;#39;filename&amp;#39;, {encoding:&amp;#39;utf8&amp;#39;},function(err, con) { 	if (err) { 	reject(err) 	return 	} 	resolve(con) 	}) 	}); } Promise.resolve #  只接受一个参数，并返回一个完成态的Promise；如果传入的是一个Promise，那么换个Promise会被立即返回
let p1 = Promise.resolve(42) p1.then(value=&amp;gt;console.log(value)); // 42 Promise.</description>
    </item>
    
  </channel>
</rss>
