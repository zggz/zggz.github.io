<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="概述 #  多数浏览器使用单一进程来处理用户界面（UI）刷新和javascript脚本的执行，所以同一时间只能做一件事，js执行时间越久，浏览器等待响应时间就越长。script标签的每次出现，页面会等待脚本的解析和执行；不管是和内联好还是外链，页面的下载和渲染都必须等待脚本 的执行。这个过程中的页面交互式完全阻塞的。
脚本位置 script标签位置 #   浏览器在解析到body标签之前不会渲染任何页面，如果把脚本放在顶部，通常表现为页面空白 每个脚本必须等到前一个脚本下载完成、执行完成才会开始下载和执行；瀑布图中显示的下载间隔刚好是前一个脚本的执行时间   结论：推荐将所有的&lt;script&gt;标签尽可能的放到标签的底部，以尽量减少对整个页面下载的影响  组织脚本 #   由于每个&lt;script&gt;标签的初始下载都会阻塞页面的渲染，减少页面包含的&lt;script&gt;标签有利于改善性能； 考虑到http的网络消耗，下载单个100k会比4个25k要快同时浏览器解析html页面每遇到一个脚本标签，都会因为执行脚本导致一定的延迟，因此脚本的数量也需要限制。 （Steve Souders）把内联的脚本放在&lt;link&gt;标签之后,也会导致页面阻塞去等待样式表的下载。（目的：确保内嵌脚本在执行时能或得最精准的样式信息），建议永远不需要把内嵌脚本放在&lt;link&gt;标签之后 脚本合并：通常将多个文件合并成一个文件下载，比如Yahoo的合并处理器  1.静态资源打包：服务器将多个文件合并成一个文件 &lt;script src=&#34;http://a.tbcdn.cn/??s/kissy/1.1.6/kissy-min.js,p/global/1.0/global-min.js,p/et/et.js?t=2011092320110301.js&#34;&gt;&lt;/script&gt; 针对上面这个案例，那么服务器端你在这个请求的接口里，根据js参数的值，把a.js到e.js的内容读取出来，再合并成一个文件（一般同时还会压缩，比如去空格，比如缩短变量名等），输出到客户端。如果服务器端再加上缓存，那可能连合并都不需要了。这样页面加载速度会快非常多。比较常用的js打包工具有google的google closure，css用yui compressor。 无阻塞脚本 #  核心在于页面加载完成后才加载javascript代码，意味着window对象的load事件触发后在加载脚本
 并行下载&lt;script&gt;标签在下载外部资源不会阻塞其他的&lt;script&gt;标签。虽然脚本的下载过程不会相互影响，但是页面仍然会等待所有的脚本下载并执行才能继续。 扩展属性（共同点都是并行下载）  defer:（html4）指明本元素所包含的脚本不会修改dom，代码可以安全的延迟执行（只有IE支持），该属性会在并行下载后等待页面完成后执行；任何带有defer属性的javascript文件下载时，它不会阻塞浏览器的其他进程，因此这类文件可以与页面其他资源并行下载(仅当src属性声明时才生效) sync:（html5）加载完成后自动执行     动态脚本元素 #  动态添加脚本元素到页面，使用动态脚本下载，返回的代码通常会立即执行
function loadScript(url,callback){  var script = document.createElement(&#39;script&#39;)  script.type = &#39;text/javascript&#39;  if(script.readyState){  // 兼容IE  script.onreadystatechange = function(){  if(script.">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="加载与执行" />
<meta property="og:description" content="概述 #  多数浏览器使用单一进程来处理用户界面（UI）刷新和javascript脚本的执行，所以同一时间只能做一件事，js执行时间越久，浏览器等待响应时间就越长。script标签的每次出现，页面会等待脚本的解析和执行；不管是和内联好还是外链，页面的下载和渲染都必须等待脚本 的执行。这个过程中的页面交互式完全阻塞的。
脚本位置 script标签位置 #   浏览器在解析到body标签之前不会渲染任何页面，如果把脚本放在顶部，通常表现为页面空白 每个脚本必须等到前一个脚本下载完成、执行完成才会开始下载和执行；瀑布图中显示的下载间隔刚好是前一个脚本的执行时间   结论：推荐将所有的&lt;script&gt;标签尽可能的放到标签的底部，以尽量减少对整个页面下载的影响  组织脚本 #   由于每个&lt;script&gt;标签的初始下载都会阻塞页面的渲染，减少页面包含的&lt;script&gt;标签有利于改善性能； 考虑到http的网络消耗，下载单个100k会比4个25k要快同时浏览器解析html页面每遇到一个脚本标签，都会因为执行脚本导致一定的延迟，因此脚本的数量也需要限制。 （Steve Souders）把内联的脚本放在&lt;link&gt;标签之后,也会导致页面阻塞去等待样式表的下载。（目的：确保内嵌脚本在执行时能或得最精准的样式信息），建议永远不需要把内嵌脚本放在&lt;link&gt;标签之后 脚本合并：通常将多个文件合并成一个文件下载，比如Yahoo的合并处理器  1.静态资源打包：服务器将多个文件合并成一个文件 &lt;script src=&#34;http://a.tbcdn.cn/??s/kissy/1.1.6/kissy-min.js,p/global/1.0/global-min.js,p/et/et.js?t=2011092320110301.js&#34;&gt;&lt;/script&gt; 针对上面这个案例，那么服务器端你在这个请求的接口里，根据js参数的值，把a.js到e.js的内容读取出来，再合并成一个文件（一般同时还会压缩，比如去空格，比如缩短变量名等），输出到客户端。如果服务器端再加上缓存，那可能连合并都不需要了。这样页面加载速度会快非常多。比较常用的js打包工具有google的google closure，css用yui compressor。 无阻塞脚本 #  核心在于页面加载完成后才加载javascript代码，意味着window对象的load事件触发后在加载脚本
 并行下载&lt;script&gt;标签在下载外部资源不会阻塞其他的&lt;script&gt;标签。虽然脚本的下载过程不会相互影响，但是页面仍然会等待所有的脚本下载并执行才能继续。 扩展属性（共同点都是并行下载）  defer:（html4）指明本元素所包含的脚本不会修改dom，代码可以安全的延迟执行（只有IE支持），该属性会在并行下载后等待页面完成后执行；任何带有defer属性的javascript文件下载时，它不会阻塞浏览器的其他进程，因此这类文件可以与页面其他资源并行下载(仅当src属性声明时才生效) sync:（html5）加载完成后自动执行     动态脚本元素 #  动态添加脚本元素到页面，使用动态脚本下载，返回的代码通常会立即执行
function loadScript(url,callback){  var script = document.createElement(&#39;script&#39;)  script.type = &#39;text/javascript&#39;  if(script.readyState){  // 兼容IE  script.onreadystatechange = function(){  if(script." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zggz.github.io/draft/high-javascript/load-and-execute/" /><meta property="article:section" content="draft" />
<meta property="article:published_time" content="2019-01-31T15:20:48+00:00" />
<meta property="article:modified_time" content="2022-04-30T11:56:44+08:00" />

<title>加载与执行 | zggz Book</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css" integrity="sha256-gsXb0jRHzuC0wqo&#43;0Izglh&#43;qQOH6Nw7uT4yfAuDUa18=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.07b4e6ed6f11d374417c3da2bd267ef2cbba85330f67ac002ed3f7537258480e.js" integrity="sha256-B7Tm7W8R03RBfD2ivSZ&#43;8su6hTMPZ6wALtP3U3JYSA4=" crossorigin="anonymous"></script>

  <script defer src="/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js" integrity="sha256-b2&#43;Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC&#43;NdcPIvZhzk=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/logo.gif" alt="Logo" /><span>zggz Book</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>一些杂记</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/notes/vim/" class="">vim常用命令</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/notes/git/" class="">Git</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>











  
<ul>
  
  <li>
    <a href="/posts/" >
        其他
      </a>
  </li>
  
  <li>
    <a href="/readbook/" >
        读书笔记
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>加载与执行</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#概述">概述</a>
      <ul>
        <li><a href="#脚本位置--script标签位置">脚本位置  script标签位置</a></li>
        <li><a href="#组织脚本">组织脚本</a></li>
        <li><a href="#无阻塞脚本">无阻塞脚本</a></li>
        <li><a href="#动态脚本元素">动态脚本元素</a></li>
      </ul>
    </li>
    <li><a href="#小结">小结</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="概述">
  概述
  <a class="anchor" href="#%e6%a6%82%e8%bf%b0">#</a>
</h1>
<p>多数浏览器使用单一进程来处理用户界面（UI）刷新和javascript脚本的执行，所以同一时间只能做一件事，js执行时间越久，浏览器等待响应时间就越长。script标签的每次出现，页面会等待脚本的解析和执行；不管是和内联好还是外链，页面的下载和渲染都必须等待脚本 的执行。这个过程中的页面交互式完全阻塞的。</p>
<!-- more -->
<h2 id="脚本位置--script标签位置">
  脚本位置  script标签位置
  <a class="anchor" href="#%e8%84%9a%e6%9c%ac%e4%bd%8d%e7%bd%ae--script%e6%a0%87%e7%ad%be%e4%bd%8d%e7%bd%ae">#</a>
</h2>
<ol>
<li>浏览器在解析到body标签之前不会渲染任何页面，如果把脚本放在顶部，通常表现为<font color=red >页面空白</font></li>
<li>每个脚本必须等到前一个脚本<font color=red >下载完成</font>、<font color=red >执行完成</font>才会开始下载和执行；瀑布图中显示的下载间隔刚好是前一个脚本的执行时间</li>
</ol>
<ul>
<li>结论：推荐将所有的&lt;script&gt;标签尽可能的放到<body>标签的底部，以尽量减少对整个页面下载的影响</li>
</ul>
<h2 id="组织脚本">
  组织脚本
  <a class="anchor" href="#%e7%bb%84%e7%bb%87%e8%84%9a%e6%9c%ac">#</a>
</h2>
<ol>
<li>由于每个&lt;script&gt;标签的初始下载都会阻塞页面的渲染，减少页面包含的&lt;script&gt;标签有利于改善性能；</li>
<li>考虑到http的网络消耗，下载单个100k会比4个25k要快同时浏览器解析html页面每遇到一个脚本标签，都会因为执行脚本导致一定的延迟，因此脚本的数量也需要限制。</li>
<li>（Steve Souders）把内联的脚本放在&lt;link&gt;标签之后,也会导致页面阻塞去等待样式表的下载。（目的：确保内嵌脚本在执行时能或得最精准的样式信息），建议永远不需要把内嵌脚本放在&lt;link&gt;标签之后</li>
<li>脚本合并：通常将多个文件合并成一个文件下载，比如Yahoo的合并处理器</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#ae81ff">1.</span><span style="color:#a6e22e">静态资源打包</span><span style="color:#960050;background-color:#1e0010">：</span><span style="color:#a6e22e">服务器将多个文件合并成一个文件</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">script</span> <span style="color:#a6e22e">src</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;http://a.tbcdn.cn/??s/kissy/1.1.6/kissy-min.js,p/global/1.0/global-min.js,p/et/et.js?t=2011092320110301.js&#34;</span><span style="color:#f92672">&gt;&lt;</span><span style="color:#960050;background-color:#1e0010">/script&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">针对上面这个案例</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">那么服务器端你在这个请求的接口里</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">根据js参数的值</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">把a</span>.<span style="color:#a6e22e">js到e</span>.<span style="color:#a6e22e">js的内容读取出来</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">再合并成一个文件</span><span style="color:#960050;background-color:#1e0010">（</span><span style="color:#a6e22e">一般同时还会压缩</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">比如去空格</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">比如缩短变量名等</span><span style="color:#960050;background-color:#1e0010">），</span><span style="color:#a6e22e">输出到客户端</span><span style="color:#960050;background-color:#1e0010">。</span><span style="color:#a6e22e">如果服务器端再加上缓存</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">那可能连合并都不需要了</span><span style="color:#960050;background-color:#1e0010">。</span><span style="color:#a6e22e">这样页面加载速度会快非常多</span><span style="color:#960050;background-color:#1e0010">。</span><span style="color:#a6e22e">比较常用的js打包工具有google的google</span> <span style="color:#a6e22e">closure</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">css用yui</span> <span style="color:#a6e22e">compressor</span><span style="color:#960050;background-color:#1e0010">。</span>
</span></span></code></pre></div><h2 id="无阻塞脚本">
  无阻塞脚本
  <a class="anchor" href="#%e6%97%a0%e9%98%bb%e5%a1%9e%e8%84%9a%e6%9c%ac">#</a>
</h2>
<p>核心在于页面加载完成后才加载javascript代码，意味着window对象的load事件触发后在加载脚本</p>
<ol>
<li>并行下载&lt;script&gt;标签在下载外部资源不会阻塞其他的&lt;script&gt;标签。虽然脚本的<font color=#9B30FF >下载过程</font>不会相互影响，但是页面仍然会等待所有的脚本下载并执行才能继续。</li>
<li>扩展属性（共同点都是并行下载）
<ul>
<li>defer:（html4）指明本元素所包含的脚本不会修改dom，代码可以安全的延迟执行（只有IE支持），该属性会在并行下载后等待<font color=green >页面完成后执行</font>；任何带有defer属性的javascript文件下载时，它不会阻塞浏览器的其他进程，因此这类文件可以与页面其他资源并行下载(仅当src属性声明时才生效)</li>
<li>sync:（html5）加载完成后<font color=green >自动执行</font>

  <img src="/images/1.png" alt="image" /></li>
</ul>
</li>
</ol>
<h2 id="动态脚本元素">
  动态脚本元素
  <a class="anchor" href="#%e5%8a%a8%e6%80%81%e8%84%9a%e6%9c%ac%e5%85%83%e7%b4%a0">#</a>
</h2>
<p>动态添加脚本元素到页面，使用动态脚本下载，返回的代码通常会立即执行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">loadScript</span>(<span style="color:#a6e22e">url</span>,<span style="color:#a6e22e">callback</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">script</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">createElement</span>(<span style="color:#e6db74">&#39;script&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">script</span>.<span style="color:#a6e22e">type</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;text/javascript&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">script</span>.<span style="color:#a6e22e">readyState</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 兼容IE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">script</span>.<span style="color:#a6e22e">onreadystatechange</span>  <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">script</span>.<span style="color:#a6e22e">readyState</span><span style="color:#f92672">==</span><span style="color:#e6db74">&#39;loaded&#39;</span><span style="color:#f92672">||</span><span style="color:#a6e22e">script</span>.<span style="color:#a6e22e">readyState</span><span style="color:#f92672">==</span><span style="color:#e6db74">&#39;complete&#39;</span>){
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">script</span>.<span style="color:#a6e22e">onreadystatechange</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">callback</span>()
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">script</span>.<span style="color:#a6e22e">onload</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(){
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">callback</span>()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">script</span>.<span style="color:#a6e22e">url</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">url</span>
</span></span><span style="display:flex;"><span>    document.<span style="color:#a6e22e">getElementsByTagName</span>(<span style="color:#e6db74">&#39;head&#39;</span>)[<span style="color:#ae81ff">0</span>].<span style="color:#a6e22e">appendChild</span>(<span style="color:#a6e22e">script</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 调用 将代码放到body闭合标签前；1）确保js执行不会阻塞页面；2）避免监听其他事件比如window.onload
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">loadScript</span>(<span style="color:#e6db74">&#39;test.js&#39;</span>,<span style="color:#66d9ef">function</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// do something
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>})
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">可以使用YUI3</span><span style="color:#960050;background-color:#1e0010">、</span><span style="color:#a6e22e">LazyLoad</span><span style="color:#960050;background-color:#1e0010">、</span><span style="color:#a6e22e">LABjs来完成类似的工作</span>
</span></span></code></pre></div><h1 id="小结">
  小结
  <a class="anchor" href="#%e5%b0%8f%e7%bb%93">#</a>
</h1>
<ol>
<li>将所有脚本放在页面的底部加载执行</li>
<li>合并脚本</li>
<li>无阻塞下载
<ul>
<li>defer属性、sync属性</li>
<li>动态脚本元素</li>
<li>xhr下载脚本注入</li>
</ul>
</li>
</ol>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">


  <div><a class="flex align-center" href="https://github.com/zggz/zggz/commit/bf76c319c4757d2fdf384578d6356ebceaece734" title='Last modified by qin | April 30, 2022' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>April 30, 2022</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/zggz/zggz//blob/main//content/draft/high-javascript/load-and-execute.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>


</div>



  <script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#概述">概述</a>
      <ul>
        <li><a href="#脚本位置--script标签位置">脚本位置  script标签位置</a></li>
        <li><a href="#组织脚本">组织脚本</a></li>
        <li><a href="#无阻塞脚本">无阻塞脚本</a></li>
        <li><a href="#动态脚本元素">动态脚本元素</a></li>
      </ul>
    </li>
    <li><a href="#小结">小结</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












