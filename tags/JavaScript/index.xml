<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JavaScript on zggz Book</title>
    <link>https://zggz.github.io/tags/JavaScript/</link>
    <description>Recent content in JavaScript on zggz Book</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 19 Nov 2020 00:18:12 +0000</lastBuildDate><atom:link href="https://zggz.github.io/tags/JavaScript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>高性能JavaScript</title>
      <link>https://zggz.github.io/draft/high-javascript/</link>
      <pubDate>Thu, 19 Nov 2020 00:18:12 +0000</pubDate>
      
      <guid>https://zggz.github.io/draft/high-javascript/</guid>
      <description></description>
    </item>
    
    <item>
      <title>代理和反射</title>
      <link>https://zggz.github.io/draft/javascript/reflect-proxy/</link>
      <pubDate>Sat, 09 May 2020 15:12:09 +0000</pubDate>
      
      <guid>https://zggz.github.io/draft/javascript/reflect-proxy/</guid>
      <description>代理(Proxy)是一种可以拦截并改变底层JavaScript引擎的操作包装器，在新语言中通过它暴露内部运作对象，从而让开发者可以创建内建对象
代理和反射 #  代理 #  调用new Proxy()可以创建代替其他目标对象的代理，虚拟化了目标，使其二者看起来功能一致，代理可以拦截JavaScript引擎内部目标的底层对象操作，这些底层操作被拦截后会触发响应特定操作的陷阱函数。
用Proxy构造函数创建代理需要两个参数： 目标(target)和处理程序(handler)，处理程序定义一个或者多个陷阱的对象，除去专门特定的操作定义外，其余操作均使用默认特性
let t = {} let p = new Proxy(t, {}) p.name = &amp;#39;hello proxy&amp;#39; console.log(p); // { name: &amp;#39;hello proxy&amp;#39; } console.log(t); // { name: &amp;#39;hello proxy&amp;#39; } 反射 #  反射API以Reflect对象的形式出现，对象中的方法默认特性相应的底层操作一致。而每一个代理陷阱会对应一个命名和参数都相同的Reflect方法(其实就是每个代理陷阱都会对应一个Reflect api接口供覆写JavaScript底层操作)
代理陷阱特性
   代理陷阱 覆写的特性 默认特性     get 读写一个属性值 Reflect.get()   set 写入一个属性 Reflect.set()   has in操作 Reflect.has()   deleteProperty delete操作符 Reflect.</description>
    </item>
    
  </channel>
</rss>
