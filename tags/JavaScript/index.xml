<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JavaScript on zggz Book</title>
    <link>https://zggz.github.io/tags/JavaScript/</link>
    <description>Recent content in JavaScript on zggz Book</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 25 Nov 2020 18:14:05 +0000</lastBuildDate><atom:link href="https://zggz.github.io/tags/JavaScript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>浏览器渲染</title>
      <link>https://zggz.github.io/draft/readbook/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/</link>
      <pubDate>Wed, 25 Nov 2020 18:14:05 +0000</pubDate>
      
      <guid>https://zggz.github.io/draft/readbook/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;
  Introduction
  &lt;a class=&#34;anchor&#34; href=&#34;#introduction&#34;&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;主要描述浏览器的渲染&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>高性能JavaScript</title>
      <link>https://zggz.github.io/draft/high-javascript/</link>
      <pubDate>Thu, 19 Nov 2020 00:18:12 +0000</pubDate>
      
      <guid>https://zggz.github.io/draft/high-javascript/</guid>
      <description></description>
    </item>
    
    <item>
      <title>函数式编程</title>
      <link>https://zggz.github.io/draft/readbook/function/</link>
      <pubDate>Thu, 25 Jun 2020 12:31:44 +0000</pubDate>
      
      <guid>https://zggz.github.io/draft/readbook/function/</guid>
      <description>&lt;h1 id=&#34;函数式编程&#34;&gt;
  函数式编程
  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b&#34;&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;使用函数来抽象作用在数据之上的控制流与操作，从而在系统中消除副作用并减少对状态的改变
函数式编程指创建不可变的程序，通过消除外部可见的副作用，来对纯函数的声明式的求值过程&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>代理和反射</title>
      <link>https://zggz.github.io/draft/javascript/reflect-proxy/</link>
      <pubDate>Sat, 09 May 2020 15:12:09 +0000</pubDate>
      
      <guid>https://zggz.github.io/draft/javascript/reflect-proxy/</guid>
      <description>代理(Proxy)是一种可以拦截并改变底层JavaScript引擎的操作包装器，在新语言中通过它暴露内部运作对象，从而让开发者可以创建内建对象
代理和反射 #  代理 #  调用new Proxy()可以创建代替其他目标对象的代理，虚拟化了目标，使其二者看起来功能一致，代理可以拦截JavaScript引擎内部目标的底层对象操作，这些底层操作被拦截后会触发响应特定操作的陷阱函数。
用Proxy构造函数创建代理需要两个参数： 目标(target)和处理程序(handler)，处理程序定义一个或者多个陷阱的对象，除去专门特定的操作定义外，其余操作均使用默认特性
let t = {} let p = new Proxy(t, {}) p.name = &amp;#39;hello proxy&amp;#39; console.log(p); // { name: &amp;#39;hello proxy&amp;#39; } console.log(t); // { name: &amp;#39;hello proxy&amp;#39; } 反射 #  反射API以Reflect对象的形式出现，对象中的方法默认特性相应的底层操作一致。而每一个代理陷阱会对应一个命名和参数都相同的Reflect方法(其实就是每个代理陷阱都会对应一个Reflect api接口供覆写JavaScript底层操作)
代理陷阱特性
   代理陷阱 覆写的特性 默认特性     get 读写一个属性值 Reflect.get()   set 写入一个属性 Reflect.set()   has in操作 Reflect.has()   deleteProperty delete操作符 Reflect.</description>
    </item>
    
  </channel>
</rss>
